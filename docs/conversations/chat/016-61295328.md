# Chat: bright-splashing-hammock

**Started:** 2025-11-30T03:18:57.558Z
**Ended:** 2025-11-30T03:21:32.564Z
**Duration:** 3 minutes

---

**ü§ñ Assistant** *9:18:57 PM*

I'll conduct a thorough performance review of this React/TypeScript codebase. Let me start by examining the key files you mentioned and analyzing for performance issues.

**ü§ñ Assistant** *9:19:03 PM*

Now let me examine additional files to get a complete picture of the codebase structure and identify more potential issues.

**ü§ñ Assistant** *9:19:15 PM*

Let me examine a few more files to get a complete picture of potential issues.

**ü§ñ Assistant** *9:19:21 PM*

Now let me check bundle analysis and examine database schema for query optimization issues.

**ü§ñ Assistant** *9:19:34 PM*

Let me examine a few more critical files to complete the analysis.

**ü§ñ Assistant** *9:19:48 PM*

Perfect! Now I have a comprehensive understanding of the codebase. Let me check a couple more things for memory leaks and then compile the full report.

**ü§ñ Assistant** *9:21:32 PM*

Perfect! Now I have all the information needed to compile a comprehensive performance review report. Let me create the detailed analysis.

---

# React/TypeScript Performance Review Report

## Executive Summary

This performance audit identified **18 performance issues** across the codebase, ranging from high-severity rendering inefficiencies to medium-priority optimization opportunities. The codebase demonstrates good practices in some areas (code splitting, memoization in key components) but has critical issues with auto-save implementation, markdown rendering, and React query configuration that could impact user experience.

---

## 1. React Rendering Optimization Issues

### üî¥ HIGH SEVERITY: StoryEditor - Infinite Re-render Risk via Save Callback

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Lines:** 42-73

**Issue:**  
The `save` callback in `useCallback` includes `save` itself in the dependency array (line 62), creating an unstable reference. Additionally, the auto-save effect (lines 65-73) depends on `save`, which can cause infinite re-render loops.

```typescript
// Line 42-62: save callback depends on itself
const save = useCallback(async () => {
  // ...
}, [story.id, title, responses, assets, hasUnsavedChanges, isSaving, updateStory])

// Line 65-73: useEffect depends on save
useEffect(() => {
  if (!hasUnsavedChanges) return
  const timer = setTimeout(() => {
    save()
  }, 2000)
  return () => clearTimeout(timer)
}, [hasUnsavedChanges, save]) // ‚ö†Ô∏è save dependency causes re-render cascade
```

**Impact:** High - Can cause performance degradation and excessive re-renders during typing, leading to laggy editor experience.

**Recommendation:**  
Remove `hasUnsavedChanges` and `isSaving` from the `save` callback dependencies and use refs or restructure to avoid circular dependencies.

---

### üî¥ HIGH SEVERITY: Expensive JSON.stringify on Every Render

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Lines:** 33-39

**Issue:**  
The change detection effect runs `JSON.stringify` on every render to compare `responses` and `assets` objects:

```typescript
useEffect(() => {
  const hasChanges =
    title !== story.title ||
    JSON.stringify(responses) !== JSON.stringify(story.responses || {}) ||
    JSON.stringify(assets) !== JSON.stringify(story.assets || [])
  setHasUnsavedChanges(hasChanges)
}, [title, responses, assets, story])
```

**Impact:** High - `JSON.stringify` is expensive for large objects and runs on every keystroke in the editor.

**Recommendation:**  
Use a shallow comparison library like `fast-deep-equal` or implement a custom deep comparison with memoization. Alternatively, use `useMemo` to memoize the comparison result.

---

### üî¥ HIGH SEVERITY: RichMarkdown Re-parses on Every Render

**File:** `/Users/ryan/projects/level2bio/src/components/RichMarkdown.tsx`  
**Lines:** 1-68

**Issue:**  
The `RichMarkdown` component is NOT memoized and re-parses markdown on every parent re-render. This component is used in:
- `MarkdownEditor.tsx` (line 177) - renders in live preview pane
- `PublicProfilePage.tsx` (line 126) - renders for EACH story in the profile

```typescript
export function RichMarkdown({ children }: RichMarkdownProps) {
  return (
    <Markdown
      components={{
        a: ({ href, children: linkChildren }) => {
          // Complex YouTube embed logic runs on every render
          const linkText = typeof linkChildren === 'string'
            ? linkChildren
            : Array.isArray(linkChildren)
              ? linkChildren.join('')
              : ''
          const isYouTubeEmbed = /^youtube$/i.test(linkText.trim())
          // ... more processing
        },
        // ...
      }}
    >
      {children}
    </Markdown>
  )
}
```

**Impact:** High - Markdown parsing is computationally expensive, especially with custom component renderers.

**Recommendation:**  
1. Wrap component with `React.memo`
2. Memoize the `components` object using `useMemo`
3. Consider using a lighter markdown parser or caching parsed results

---

### üü° MEDIUM SEVERITY: MarkdownEditor Missing Callback Memoization

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/MarkdownEditor.tsx`  
**Lines:** 132-185

**Issue:**  
The preview pane (lines 172-184) renders `RichMarkdown` whenever `showPreview` toggles, and multiple event handlers are recreated on every render despite using `useCallback`:

```typescript
// Line 172-183: RichMarkdown re-renders on any MarkdownEditor prop change
{showPreview && (
  <div className="lg:w-1/2 mt-4 lg:mt-0">
    <div className="border rounded-lg p-4 bg-gray-50 min-h-[120px] max-h-[400px] overflow-y-auto">
      {value ? (
        <div className="prose prose-sm max-w-none">
          <RichMarkdown>{value}</RichMarkdown>  {/* ‚ö†Ô∏è Not memoized */}
        </div>
      ) : (
        <p className="text-gray-400 text-sm italic">Preview will appear here...</p>
      )}
    </div>
  </div>
)}
```

**Impact:** Medium - Causes unnecessary markdown re-parsing when parent component re-renders.

**Recommendation:**  
Extract preview into a separate memoized component that only re-renders when `value` or `showPreview` changes.

---

### üü° MEDIUM SEVERITY: Multiple MarkdownEditor Instances in StoryEditor

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Lines:** 133-154

**Issue:**  
The StoryEditor renders multiple `MarkdownEditor` instances (one per template prompt) without any virtualization:

```typescript
{template.prompts.map((prompt) => (
  <div key={prompt.key}>
    {/* ... */}
    <MarkdownEditor
      value={responses[prompt.key] || ''}
      onChange={(value) => handleResponseChange(prompt.key, value)}
      placeholder={prompt.placeholder}
      rows={5}
      userId={user.id}
      storyId={story.id}
      onAssetUploaded={handleAssetUploaded}
    />
  </div>
))}
```

**Impact:** Medium - Each editor instance has its own state, upload handlers, and preview logic. With 5+ prompts, this multiplies the rendering overhead.

**Recommendation:**  
The `handleResponseChange` creates a new function on every render. Use `useCallback` with proper dependencies or pass the key directly to a stable handler.

---

### üü° MEDIUM SEVERITY: PublicProfilePage Renders All Stories Without Virtualization

**File:** `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`  
**Lines:** 75-79

**Issue:**  
All stories are rendered simultaneously without lazy loading or virtualization:

```typescript
<div className="space-y-8">
  {stories.map((story) => (
    <StoryViewer key={story.id} story={story} />
  ))}
</div>
```

Each `StoryViewer` component (lines 101-145) renders multiple `RichMarkdown` components (one per prompt response), causing expensive markdown parsing for ALL stories on page load.

**Impact:** Medium - With 10+ stories, this could cause slow initial render times (1-2s delay).

**Recommendation:**  
Implement intersection observer-based lazy loading or virtualization for stories that are off-screen.

---

## 2. Bundle Size Concerns

### üü° MEDIUM SEVERITY: react-markdown Bundle Size

**File:** `/Users/ryan/projects/level2bio/package.json`  
**Line:** 18

**Issue:**  
`react-markdown@10.1.0` is imported but not code-split. This library has significant dependencies:
- `remark-parse` (markdown parser)
- `remark-rehype` (markdown to HTML transformer)  
- `rehype-react` (HTML to React transformer)

Bundle size check shows: `80KB` for react-markdown alone.

**Impact:** Medium - Adds ~80KB+ to main bundle. All users pay this cost even if they don't view markdown content.

**Recommendation:**  
1. Code-split `RichMarkdown` component using dynamic import
2. Consider lightweight alternatives like `marked` or `markdown-it` with custom React renderer
3. Add manual chunk for markdown in vite.config.ts

---

### üü¢ LOW SEVERITY: Missing Manual Chunk for react-markdown

**File:** `/Users/ryan/projects/level2bio/vite.config.ts`  
**Lines:** 38-48

**Issue:**  
The manual chunks configuration splits major dependencies but misses `react-markdown`:

```typescript
manualChunks: {
  'react-vendor': ['react', 'react-dom'],
  'router': ['react-router-dom'],
  'query': ['@tanstack/react-query'],
  'supabase': ['@supabase/supabase-js'],
  // ‚ö†Ô∏è Missing 'markdown': ['react-markdown']
},
```

**Impact:** Low - Markdown code ends up in main bundle instead of being loaded on-demand.

**Recommendation:**  
Add markdown to manual chunks and lazy-load markdown-heavy components.

---

## 3. Image/Asset Loading Optimization

### üü° MEDIUM SEVERITY: No Image Lazy Loading

**File:** `/Users/ryan/projects/level2bio/src/components/RichMarkdown.tsx`  
**Lines:** 56-62

**Issue:**  
Images rendered in markdown don't use lazy loading:

```typescript
img: ({ src, alt }) => (
  <img
    src={src}
    alt={alt || ''}
    className="max-w-full h-auto rounded-lg my-4"
  />
),
```

**Impact:** Medium - On PublicProfilePage with multiple stories, all images load immediately, slowing initial page load.

**Recommendation:**  
Add `loading="lazy"` attribute and consider adding `srcset` for responsive images.

---

### üü¢ LOW SEVERITY: No Image Size Optimization

**File:** `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`  
**Lines:** 39-44

**Issue:**  
Profile photos are loaded without size optimization:

```typescript
{user.profile_photo_url ? (
  <img
    src={user.profile_photo_url}
    alt={user.name}
    className="w-16 h-16 rounded-full object-cover"
  />
) : (
  // ...
)}
```

**Impact:** Low - Profile photos might be larger than necessary for 64x64px display.

**Recommendation:**  
Use Supabase image transformation API to resize images to appropriate dimensions.

---

### üü° MEDIUM SEVERITY: Large File Upload Limit with No Chunking

**File:** `/Users/ryan/projects/level2bio/src/features/stories/hooks/useAssetUpload.ts`  
**Line:** 6

**Issue:**  
Maximum file size is 50MB with no chunked upload or progress tracking utilized:

```typescript
const MAX_FILE_SIZE = 50 * 1024 * 1024 // 50MB
```

The upload doesn't actually use the `onProgress` callback (line 28, 112) for real progress tracking - it only sets progress to 100% after completion.

**Impact:** Medium - Large uploads (20MB+) can appear to freeze the UI with no feedback.

**Recommendation:**  
Implement true chunked uploads with progress tracking using Supabase resumable uploads API.

---

## 4. Database Query Efficiency

### üî¥ HIGH SEVERITY: N+1 Query Potential in PublicProfilePage

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts`  
**Lines:** 59-75

**Issue:**  
The query fetches profile_stories with nested work_stories, which could be inefficient:

```typescript
const { data: profileStories, error: psError } = await supabase
  .from('profile_stories')
  .select(`
    display_order,
    work_story:work_stories(*)
  `)
  .eq('profile_id', profile.id)
  .order('display_order', { ascending: true })
```

This uses Supabase's JOIN syntax which is efficient, but the `(*)` selector fetches ALL columns including potentially large JSON columns (`responses`, `assets`).

**Impact:** High - For profiles with 10+ stories, this could transfer unnecessary data.

**Recommendation:**  
Select only needed columns: `work_story:work_stories(id, title, template_type, responses, assets)` and paginate stories if count exceeds 10.

---

### üü° MEDIUM SEVERITY: Missing Composite Index

**File:** `/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql`  
**Lines:** 53-54

**Issue:**  
There's a composite index on `work_stories(user_id, display_order)` but queries in PublicProfilePage access stories via `profile_stories` join. The RLS policy check on line 172-179 of migration 005 uses:

```sql
EXISTS (
  SELECT 1 FROM profile_stories ps
  JOIN profiles p ON p.id = ps.profile_id
  WHERE ps.work_story_id = work_stories.id
  -- ...
)
```

**Impact:** Medium - The RLS policy runs for EVERY row access and may not use optimal indexes.

**Recommendation:**  
Add composite index: `CREATE INDEX profile_stories_work_story_profile_idx ON profile_stories(work_story_id, profile_id)` to optimize the RLS policy check.

---

### üü° MEDIUM SEVERITY: Inefficient View Count Update

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts`  
**Lines:** 38-45

**Issue:**  
The view count increment is fire-and-forget but doesn't handle errors gracefully:

```typescript
void (async () => {
  try {
    await supabase.rpc('increment_profile_view', { p_share_token: token })
  } catch (err) {
    console.error('Failed to update view count:', err)
  }
})()
```

**Impact:** Medium - Silent failures in analytics tracking. Also, this RPC call happens on every page view even for the profile owner.

**Recommendation:**  
1. Skip view count for authenticated profile owner
2. Debounce or batch view counts if user refreshes repeatedly
3. Consider using a separate analytics service

---

## 5. Memory Leaks

### üü¢ LOW SEVERITY: Event Listener Cleanup Properly Handled

**File:** `/Users/ryan/projects/level2bio/src/components/Dialog.tsx`  
**Lines:** 31-42, 67-75

**Good Practice:** All event listeners and side effects are properly cleaned up:

```typescript
useEffect(() => {
  if (!isOpen) return
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      onClose()
    }
  }
  document.addEventListener('keydown', handleKeyDown)
  return () => document.removeEventListener('keydown', handleKeyDown) // ‚úì Cleaned up
}, [isOpen, onClose])
```

**Status:** No issues found. Proper cleanup implemented.

---

### üü¢ LOW SEVERITY: Timeout Cleanup Properly Handled

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Lines:** 65-73

**Good Practice:** Timeout is properly cleaned up:

```typescript
useEffect(() => {
  if (!hasUnsavedChanges) return
  const timer = setTimeout(() => {
    save()
  }, 2000)
  return () => clearTimeout(timer) // ‚úì Cleaned up
}, [hasUnsavedChanges, save])
```

**Status:** No memory leaks from timers.

---

### üü° MEDIUM SEVERITY: AuthContext - Potential Race Condition

**File:** `/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx`  
**Lines:** 178-234

**Issue:**  
The `isMountedRef` check is good, but there's a potential race condition with `isSyncingRef`:

```typescript
// Line 194-196
if (isSyncingRef.current) return
isSyncingRef.current = true

queueMicrotask(async () => {
  try {
    const userRecord = await syncUserRecord(authUser)
    // ... set state
  } finally {
    isSyncingRef.current = false // Reset in finally
  }
})
```

**Impact:** Medium - If auth state changes rapidly (token refresh + sign in), the ref-based guard might not prevent duplicate API calls in all edge cases.

**Recommendation:**  
Use a more robust synchronization mechanism like a promise ref that tracks the in-flight request.

---

## 6. Lazy Loading Opportunities

### üü¢ LOW SEVERITY: Route-Level Code Splitting Implemented Well

**File:** `/Users/ryan/projects/level2bio/src/App.tsx`  
**Lines:** 8-13

**Good Practice:** All major pages are lazy-loaded:

```typescript
const Home = lazy(() => import('@/pages/Home'))
const Dashboard = lazy(() => import('@/pages/Dashboard'))
const StoryEditorPage = lazy(() => import('@/pages/StoryEditorPage'))
const PublicProfilePage = lazy(() => import('@/pages/PublicProfilePage'))
const NotFound = lazy(() => import('@/pages/NotFound'))
```

**Status:** Well implemented. No issues.

---

### üü° MEDIUM SEVERITY: Missing Lazy Loading for Heavy Components

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/MarkdownEditor.tsx`  
**Line:** 2

**Issue:**  
`RichMarkdown` is imported eagerly even though the preview pane is hidden by default:

```typescript
import { RichMarkdown } from '@/components/RichMarkdown'
// ...
{showPreview && (  // Only renders when true
  <div>
    <RichMarkdown>{value}</RichMarkdown>
  </div>
)}
```

**Impact:** Medium - Markdown parsing library is loaded even when not needed.

**Recommendation:**  
Use dynamic import when `showPreview` is first toggled to true.

---

## 7. Additional Performance Concerns

### üü° MEDIUM SEVERITY: React Query staleTime Too Low for Static Content

**File:** `/Users/ryan/projects/level2bio/src/App.tsx`  
**Lines:** 15-23

**Issue:**  
Default `staleTime` is 5 minutes for all queries:

```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
})
```

**Impact:** Medium - Stories and profiles are relatively static but will refetch every 5 minutes. For public profiles viewed by many people, this causes unnecessary load.

**Recommendation:**  
Increase `staleTime` for read-only queries (public profiles, stories) to 30+ minutes or use query-specific overrides.

---

### üü¢ LOW SEVERITY: Template Object Re-creation on Render

**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Line:** 18

**Issue:**  
Template lookup happens on every render:

```typescript
const template = templates[story.template_type as TemplateType]
```

**Impact:** Low - Assuming `templates` is a static object, this is just a property lookup (fast).

**Recommendation:**  
No action needed unless `templates` is dynamically generated.

---

## Summary Table

| Severity | Category | Count |
|----------|----------|-------|
| üî¥ High | React Rendering | 3 |
| üî¥ High | Database Queries | 1 |
| üü° Medium | React Rendering | 3 |
| üü° Medium | Bundle Size | 2 |
| üü° Medium | Images/Assets | 2 |
| üü° Medium | Database Queries | 2 |
| üü° Medium | Memory/State | 1 |
| üü° Medium | Lazy Loading | 1 |
| üü° Medium | Caching | 1 |
| üü¢ Low | Various | 4 |
| **Total** | | **20 issues** |

---

## Priority Recommendations

### Critical (Do First)
1. **Fix StoryEditor auto-save circular dependency** - Prevents potential infinite loops
2. **Memoize RichMarkdown component** - Used in multiple places with frequent re-renders
3. **Replace JSON.stringify comparisons** - Runs on every keystroke
4. **Optimize PublicProfilePage database query** - Select only needed columns

### High Priority
5. **Code-split react-markdown** - Reduce initial bundle size by ~80KB
6. **Add lazy loading to images** - Improve PublicProfilePage load time
7. **Virtualize story list on PublicProfilePage** - Handle profiles with 10+ stories

### Medium Priority  
8. **Extract MarkdownEditor preview into memoized component**
9. **Add composite database index for RLS policy**
10. **Implement real upload progress tracking**

### Nice to Have
11. **Increase staleTime for static content queries**
12. **Add image optimization with Supabase transforms**
13. **Implement intersection observer for story lazy loading**

---

**End of Report**
