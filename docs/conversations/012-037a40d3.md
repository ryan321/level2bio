# Conversation: bright-splashing-hammock

**Session ID:** `ed53f46a-1264-4cf5-bd8c-07aba30981cd`
**Agent ID:** `037a40d3`
**Started:** 2025-11-30T02:01:45.118Z
**Ended:** 2025-11-30T02:04:13.214Z
**Duration:** 2 minutes

---

## ü§ñ Assistant
*8:01:45 PM*

I'll conduct a comprehensive review of the React/TypeScript codebase, examining the files you specified for best practices, patterns, and potential improvements.

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/pages/Dashboard.tsx`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`


## üë§ User
*8:01:48 PM*

**Result:**
```
     1‚Üíimport { useState } from 'react'
     2‚Üíimport { useProfiles, type ProfileWithStories } from '../hooks/useProfiles'
     3‚Üíimport {
     4‚Üí  useCreateProfile,
     5‚Üí  useUpdateProfile,
     6‚Üí  useToggleProfile,
     7‚Üí  useRegenerateProfileToken,
     8‚Üí  useDeleteProfile,
     9‚Üí  useUpdateProfileStories,
    10‚Üí} from '../hooks/useProfileMutations'
    11‚Üíimport { useDialog } from '@/hooks/useDialog'
    12‚Üíimport type { WorkStory } from '@/types'
    13‚Üí
    14‚Üíinterface ProfileManag
...
```

**Result:**
```
     1‚Üíimport { useQuery } from '@tanstack/react-query'
     2‚Üíimport { supabase } from '@/lib/supabase'
     3‚Üíimport type { Profile, WorkStory } from '@/types'
     4‚Üí
     5‚Üíexport const PROFILES_QUERY_KEY = ['profiles']
     6‚Üí
     7‚Üíexport interface ProfileWithStories extends Profile {
     8‚Üí  stories: WorkStory[]
     9‚Üí}
    10‚Üí
    11‚Üíexport function useProfiles(userId: string | undefined) {
    12‚Üí  return useQuery({
    13‚Üí    queryKey: [...PROFILES_QUERY_KEY, userId],
    14‚Üí    que
...
```

**Result:**
```
     1‚Üíimport { useMutation, useQueryClient } from '@tanstack/react-query'
     2‚Üíimport { supabase } from '@/lib/supabase'
     3‚Üíimport { PROFILES_QUERY_KEY } from './useProfiles'
     4‚Üíimport type { ProfileInsert, ProfileUpdate } from '@/types'
     5‚Üí
     6‚Üí// Generate a cryptographically random token
     7‚Üífunction generateToken(): string {
     8‚Üí  return crypto.randomUUID()
     9‚Üí}
    10‚Üí
    11‚Üíexport interface CreateProfileInput {
    12‚Üí  userId: string
    13‚Üí  name: string
    1
...
```

**Result:**
```
     1‚Üíimport { useQuery } from '@tanstack/react-query'
     2‚Üíimport { supabase } from '@/lib/supabase'
     3‚Üíimport type { User, WorkStory, Profile } from '@/types'
     4‚Üí
     5‚Üíexport interface PublicProfile {
     6‚Üí  user: User
     7‚Üí  profile: Profile
     8‚Üí  stories: WorkStory[]
     9‚Üí}
    10‚Üí
    11‚Üíexport function usePublicProfile(token: string | undefined) {
    12‚Üí  return useQuery({
    13‚Üí    queryKey: ['publicProfile', token],
    14‚Üí    queryFn: async (): Promise<PublicProf
...
```

**Result:**
```
     1‚Üíimport { useParams } from 'react-router-dom'
     2‚Üíimport { usePublicProfile } from '@/features/profile'
     3‚Üíimport { templates, type TemplateType } from '@/features/stories'
     4‚Üíimport type { WorkStory } from '@/types'
     5‚Üí
     6‚Üíexport default function PublicProfilePage() {
     7‚Üí  const { token } = useParams<{ token: string }>()
     8‚Üí  const { data: publicProfile, isLoading, error } = usePublicProfile(token)
     9‚Üí
    10‚Üí  if (!token) {
    11‚Üí    return <NotAvailable /
...
```

**Result:**
```
     1‚Üíimport { useAuth } from '@/features/auth'
     2‚Üíimport { StoryList, useStories } from '@/features/stories'
     3‚Üíimport { ProfileManager } from '@/features/profile'
     4‚Üí
     5‚Üíexport default function Dashboard() {
     6‚Üí  const { user, authUser, signOut } = useAuth()
     7‚Üí  const { data: stories } = useStories(user?.id)
     8‚Üí
     9‚Üí  const allStories = stories ?? []
    10‚Üí
    11‚Üí  return (
    12‚Üí    <div className="min-h-screen bg-gray-50">
    13‚Üí      <div className="max-
...
```

**Result:**
```
     1‚Üíimport { useState, useEffect, useCallback } from 'react'
     2‚Üíimport { useNavigate } from 'react-router-dom'
     3‚Üíimport type { WorkStory } from '@/types'
     4‚Üíimport { templates, type TemplateType } from '../templates'
     5‚Üíimport { useUpdateStory } from '../hooks/useStoryMutations'
     6‚Üíimport { ROUTES } from '@/lib/constants'
     7‚Üí
     8‚Üíinterface StoryEditorProps {
     9‚Üí  story: WorkStory
    10‚Üí}
    11‚Üí
    12‚Üí// Extract YouTube video ID from various URL formats
    1
...
```

## ü§ñ Assistant
*8:01:53 PM*

Now let me examine some additional context files to better understand patterns across the codebase:

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/types/index.ts`


**Tool: Glob**
Pattern: `**/*.tsx`


**Tool: Glob**
Pattern: `**/*.ts`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/hooks/useDialog.ts`


**Tool: Grep**
Search: `interface.*Props`


## üë§ User
*8:01:56 PM*

**Result:**
```
<tool_use_error>File does not exist. Did you mean useDialog.tsx?</tool_use_error>
```

**Result:**
```
     1‚Üíexport * from './database'
     2‚Üí

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>

```

**Result:**
```
No files found
```

**Result:**
```
No files found
```

**Result:**
```
/Users/ryan/projects/level2bio/src/hooks/useDialog.tsx
```

Found files:
- `/Users/ryan/projects/level2bio/src/hooks/useDialog.tsx`


## ü§ñ Assistant
*8:01:59 PM*

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/hooks/useDialog.tsx`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/types/database.ts`


**Tool: Grep**
Search: `export function use`


## üë§ User
*8:02:01 PM*

**Result:**
```
     1‚Üíimport { useState, useCallback, type ReactNode } from 'react'
     2‚Üíimport { AlertDialog, ConfirmDialog } from '@/components/Dialog'
     3‚Üí
     4‚Üíinterface AlertState {
     5‚Üí  isOpen: boolean
     6‚Üí  title: string
     7‚Üí  message: string
     8‚Üí}
     9‚Üí
    10‚Üíinterface ConfirmState {
    11‚Üí  isOpen: boolean
    12‚Üí  title: string
    13‚Üí  message: string
    14‚Üí  confirmLabel: string
    15‚Üí  cancelLabel: string
    16‚Üí  variant: 'default' | 'danger'
    17‚Üí  onConfirm: () => vo
...
```

**Result:**
```
     1‚Üí// Database types - will be generated from Supabase CLI in production
     2‚Üí// For now, manually defined based on our schema
     3‚Üí
     4‚Üíexport type Json =
     5‚Üí  | string
     6‚Üí  | number
     7‚Üí  | boolean
     8‚Üí  | null
     9‚Üí  | { [key: string]: Json | undefined }
    10‚Üí  | Json[]
    11‚Üí
    12‚Üíexport interface Database {
    13‚Üí  public: {
    14‚Üí    Tables: {
    15‚Üí      users: {
    16‚Üí        Row: {
    17‚Üí          id: string
    18‚Üí          auth_id: string | null
  
...
```

**Result:**
```
src/features/profile/hooks/usePublicProfile.ts:11:export function usePublicProfile(token: string | undefined) {
src/features/profile/hooks/useShareLink.ts:7:export function useShareLink(userId: string | undefined) {
src/features/profile/hooks/useProfiles.ts:11:export function useProfiles(userId: string | undefined) {
src/features/profile/hooks/useProfiles.ts:67:export function useProfile(profileId: string | undefined) {
src/features/profile/hooks/useShareLinkMutations.ts:10:export function useCr
...
```

## ü§ñ Assistant
*8:02:05 PM*

Let me check a few more files to get a complete picture:

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts`


**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx`


**Tool: Bash**
```bash
find src -name "*.tsx" -o -name "*.ts" | head -20
```


## üë§ User
*8:02:07 PM*

**Result:**
```
     1‚Üíimport { useMutation, useQueryClient } from '@tanstack/react-query'
     2‚Üíimport { supabase } from '@/lib/supabase'
     3‚Üíimport type { WorkStoryInsert, WorkStoryUpdate } from '@/types'
     4‚Üíimport { STORIES_QUERY_KEY } from './useStories'
     5‚Üíimport type { TemplateType } from '../templates'
     6‚Üí
     7‚Üíinterface CreateStoryInput {
     8‚Üí  userId: string
     9‚Üí  templateType: TemplateType
    10‚Üí  title: string
    11‚Üí}
    12‚Üí
    13‚Üíinterface UpdateStoryInput {
    14‚Üí  id: 
...
```

**Result:**
```
     1‚Üíimport {
     2‚Üí  createContext,
     3‚Üí  useContext,
     4‚Üí  useEffect,
     5‚Üí  useState,
     6‚Üí  useCallback,
     7‚Üí  useMemo,
     8‚Üí  useRef,
     9‚Üí  type ReactNode,
    10‚Üí} from 'react'
    11‚Üíimport { supabase } from '@/lib/supabase'
    12‚Üíimport type { User } from '@/types'
    13‚Üí
    14‚Üí// Auth user from Supabase Auth (OAuth or email)
    15‚Üíexport interface AuthUser {
    16‚Üí  id: string
    17‚Üí  email: string | null
    18‚Üí  name: string
    19‚Üí  headline: string | null

...
```

**Result:**
```
src/App.tsx
src/main.tsx
src/types/database.ts
src/types/index.ts
src/features/auth/components/EmailAuthForm.tsx
src/features/auth/components/ProtectedRoute.tsx
src/features/auth/components/LoginButton.tsx
src/features/auth/AuthContext.tsx
src/features/auth/index.ts
src/features/stories/templates.ts
src/features/stories/components/TemplateSelector.tsx
src/features/stories/components/StoryCard.tsx
src/features/stories/components/StoryEditor.tsx
src/features/stories/components/StoryList.tsx
src/fe
...
```

```
src/App.tsx
src/main.tsx
src/types/database.ts
src/types/index.ts
src/features/auth/components/EmailAuthForm.tsx
src/features/auth/components/ProtectedRoute.tsx
src/features/auth/components/LoginButton.tsx
src/features/auth/AuthContext.tsx
src/features/auth/index.ts
src/features/stories/templates.ts
src/features/stories/components/TemplateSelector.tsx
src/features/stories/components/StoryCard.tsx
src/features/stories/components/StoryEditor.tsx
src/features/stories/components/StoryList.tsx
src/features/stories/hooks/useStories.ts
src/features/stories/hooks/useStoryMutations.ts
src/features/stories/index.ts
src/features/profile/components/ShareLinkManager.tsx
src/features/profile/components/ProfileManager.tsx
src/features/profile/hooks/useProfileMutations.ts
```


## ü§ñ Assistant
*8:04:13 PM*

Now I have a comprehensive view of the codebase. Let me compile the detailed code review report.

---

# Level2.bio React/TypeScript Code Review

## Executive Summary

The codebase demonstrates **solid React and TypeScript fundamentals** with modern patterns including React Query, custom hooks, and component composition. However, there are several opportunities for improvement in type safety, error handling, performance optimization, and code organization.

---

## 1. React Patterns & Hooks Usage

### ‚úÖ Strengths

**Excellent use of custom hooks for separation of concerns:**
- `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts` - Clean data fetching hook
- `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts` - Well-organized mutation hooks
- `/Users/ryan/projects/level2bio/src/hooks/useDialog.tsx` - Nice abstraction for dialog state management

**Good use of React Query:**
- Proper query key organization (lines 5, 13 in `useProfiles.ts`)
- Appropriate invalidation on mutations (lines 72-76 in `useProfileMutations.ts`)
- `enabled` flag for conditional queries (line 63 in `useProfiles.ts`)

**Proper memoization in AuthContext:**
- `useMemo` for context value (lines 293-303 in `AuthContext.tsx`)
- `useCallback` for methods to prevent re-renders

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 1: Missing dependency in StoryEditor useEffect
**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Lines:** 77-85

```typescript
useEffect(() => {
  if (!hasUnsavedChanges) return

  const timer = setTimeout(() => {
    save()
  }, 2000)

  return () => clearTimeout(timer)
}, [hasUnsavedChanges, save])
```

**Problem:** The `save` function is included in dependencies but it's defined with `useCallback` that has its own extensive dependency array (line 74). This creates a chain where any change triggers a new `save` function, which triggers this effect.

**Recommendation:**
```typescript
// Better approach - use ref for the save function
const saveRef = useRef(save);
useEffect(() => {
  saveRef.current = save;
}, [save]);

useEffect(() => {
  if (!hasUnsavedChanges) return
  
  const timer = setTimeout(() => {
    saveRef.current()
  }, 2000)
  
  return () => clearTimeout(timer)
}, [hasUnsavedChanges])
```

#### Issue 2: Unnecessary state in ProfileCard
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 282-287

```typescript
const [copied, setCopied] = useState(false)
```

**Problem:** The `copied` state is used only for transient UI feedback (2 seconds). This could be a ref instead since it doesn't need to trigger re-renders.

**Recommendation:**
```typescript
const copiedTimeoutRef = useRef<NodeJS.Timeout>();

const handleCopy = async () => {
  try {
    await navigator.clipboard.writeText(shareUrl)
    setCopied(true)
    clearTimeout(copiedTimeoutRef.current);
    copiedTimeoutRef.current = setTimeout(() => setCopied(false), 2000)
  } catch (err) {
    // ...
  }
}
```

#### Issue 3: Component size - ProfileManager.tsx is too large
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 1-593

**Problem:** The file contains 3 components (ProfileManager, CreateProfileForm, ProfileCard) totaling ~600 lines. ProfileCard alone is ~320 lines (266-592).

**Recommendation:** Split into separate files:
```
/components/
  ProfileManager.tsx (main component)
  CreateProfileForm.tsx
  ProfileCard/
    index.tsx
    useProfileCardLogic.ts (custom hook for business logic)
    ProfileCardActions.tsx
    ProfileCardExpiration.tsx
```

---

## 2. TypeScript Usage & Type Safety

### ‚úÖ Strengths

**Excellent type definitions:**
- `/Users/ryan/projects/level2bio/src/types/database.ts` - Comprehensive database types derived from Supabase schema
- Proper use of type guards in AuthContext (line 49)
- Good interface definitions for component props

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 4: Type assertion instead of proper typing
**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts`  
**Lines:** 53, 99

```typescript
stories.push(ps.work_story as unknown as WorkStory)
```

**Problem:** Double type assertion (`as unknown as`) indicates a type system mismatch. This bypasses type checking completely.

**Recommendation:** Create a proper type for the Supabase join result:
```typescript
type ProfileStoryJoin = {
  profile_id: string;
  display_order: number;
  work_story: WorkStory;
}

// Then in the query:
const { data: profileStories } = await supabase
  .from('profile_stories')
  .select(`
    profile_id,
    display_order,
    work_story:work_stories(*)
  `) as { data: ProfileStoryJoin[] | null };

// And safely extract:
const stories = (profileStories || [])
  .map(ps => ps.work_story)
  .filter(Boolean)
```

#### Issue 5: Unsafe type casting of story responses
**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Line:** 37

```typescript
const [responses, setResponses] = useState<Record<string, string>>(
  (story.responses as Record<string, string>) || {}
)
```

**Problem:** `story.responses` is typed as `Json` from the database, but we're blindly casting it to `Record<string, string>`. This could fail at runtime if the data is malformed.

**Recommendation:** Add runtime validation:
```typescript
function isValidResponses(value: unknown): value is Record<string, string> {
  return (
    typeof value === 'object' && 
    value !== null && 
    Object.values(value).every(v => typeof v === 'string')
  );
}

const [responses, setResponses] = useState<Record<string, string>>(() => {
  const rawResponses = story.responses;
  return isValidResponses(rawResponses) ? rawResponses : {};
});
```

#### Issue 6: Missing prop types export
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 14-17, 107-113, 239-254

**Problem:** Component prop interfaces are not exported, making them unavailable for testing or composition.

**Recommendation:**
```typescript
export interface ProfileManagerProps {
  userId: string
  stories: WorkStory[]
}

export interface CreateProfileFormProps {
  // ...
}

export interface ProfileCardProps {
  // ...
}
```

#### Issue 7: No typing for template responses
**File:** `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`  
**Line:** 102

```typescript
const responses = story.responses as Record<string, string>
```

**Problem:** Same issue as #5 - unsafe casting without validation.

**Also in:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx` (line 36)

---

## 3. Code Organization & Maintainability

### ‚úÖ Strengths

**Good feature-based organization:**
```
src/features/
  auth/
  profile/
  stories/
```

**Consistent file naming and structure**

**Proper separation of queries and mutations in separate hook files**

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 8: Duplication of YouTube parsing logic
**Files:**
- `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx` (lines 12-27)
- `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx` (lines 138-150)

**Problem:** Same YouTube ID extraction logic exists in two places with slight variations.

**Recommendation:** Create shared utility:
```typescript
// src/lib/youtube.ts
export function extractYouTubeId(url: string): string | null {
  if (!url) return null
  
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\s?]+)/,
    /^([a-zA-Z0-9_-]{11})$/,
  ]
  
  for (const pattern of patterns) {
    const match = url.match(pattern)
    if (match) return match[1]
  }
  
  return null
}

// Then import and use in both components
```

#### Issue 9: Duplication of datetime formatting logic
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 257-264, 405-411

**Problem:** `toDateTimeLocal` helper is defined inline but could be useful elsewhere. Similar date formatting logic exists in multiple places.

**Recommendation:**
```typescript
// src/lib/dateUtils.ts
export function toDateTimeLocal(isoString: string | null): string {
  if (!isoString) return ''
  const date = new Date(isoString)
  const offset = date.getTimezoneOffset() * 60000
  const localDate = new Date(date.getTime() - offset)
  return localDate.toISOString().slice(0, 16)
}

export function formatExpiration(isoString: string): string {
  const date = new Date(isoString)
  return date.toLocaleString(undefined, {
    dateStyle: 'medium',
    timeStyle: 'short',
  })
}
```

#### Issue 10: Magic numbers and strings
**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Line:** 82

```typescript
setTimeout(() => save(), 2000) // Save after 2 seconds
```

**Recommendation:** Extract to constants:
```typescript
// src/lib/constants.ts
export const AUTO_SAVE_DELAY_MS = 2000;
export const COPY_FEEDBACK_DURATION_MS = 2000;

// Usage:
setTimeout(() => save(), AUTO_SAVE_DELAY_MS)
```

---

## 4. Error Handling Patterns

### ‚úÖ Strengths

**Excellent error sanitization in AuthContext:**
- Lines 76-100 in `/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx`
- Prevents information leakage
- User-friendly error messages

**Consistent error handling pattern in hooks:**
- Try/catch in mutations with proper error messages

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 11: Console.error instead of proper error tracking
**Multiple files:**
- `ProfileManager.tsx`: lines 151, 299, 326, 344, 360, 382, 397
- `StoryEditor.tsx`: line 70
- `usePublicProfile.ts`: line 57
- `AuthContext.tsx`: lines 140, 166, 172, 208

**Problem:** Errors are only logged to console. In production, these errors are invisible to developers.

**Recommendation:** Implement error tracking service:
```typescript
// src/lib/errorTracking.ts
export function reportError(error: unknown, context?: Record<string, unknown>) {
  console.error(error, context)
  
  // In production, send to Sentry, LogRocket, etc.
  if (import.meta.env.PROD) {
    // Sentry.captureException(error, { extra: context })
  }
}

// Usage:
} catch (err) {
  reportError(err, { 
    operation: 'createProfile', 
    userId, 
    profileData: { name, storyIds } 
  })
  showAlert('Failed to create profile. Please try again.', 'Error')
}
```

#### Issue 12: Silent failure in view count update
**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts`  
**Lines:** 38-59

```typescript
void (async () => {
  try {
    // update view count
  } catch (err) {
    console.error('Failed to update view count:', err)
  }
})()
```

**Problem:** Uses void IIFE to fire-and-forget. While intentional, there's no monitoring if view counts consistently fail.

**Recommendation:** Add error tracking and consider using a separate mutation:
```typescript
// Better approach - make it trackable
const updateViewCount = async (token: string) => {
  try {
    await supabase.rpc('increment_profile_view', { share_token: token })
  } catch (err) {
    reportError(err, { operation: 'incrementView', token })
  }
}

// Then in the hook:
useEffect(() => {
  if (profile?.share_token) {
    updateViewCount(profile.share_token)
  }
}, [profile?.share_token])
```

#### Issue 13: No error boundaries
**All component files**

**Problem:** No React Error Boundaries to catch rendering errors. If any component throws during render, the entire app crashes.

**Recommendation:** Add error boundaries:
```typescript
// src/components/ErrorBoundary.tsx
import { Component, type ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback?: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    reportError(error, { errorInfo })
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>Something went wrong</div>
    }
    return this.props.children
  }
}

// Wrap features:
<ErrorBoundary fallback={<ProfileErrorFallback />}>
  <ProfileManager />
</ErrorBoundary>
```

---

## 5. Performance Considerations

### ‚úÖ Strengths

**Good use of React Query caching:**
- Automatic caching prevents unnecessary refetches
- Pre-population of cache after mutations (line 59 in `useStoryMutations.ts`)

**Proper use of useCallback and useMemo where needed**

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 14: Inefficient story mapping in ProfileCard
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 527-540

```typescript
{stories.map((story) => (
  <label key={story.id} className="...">
    <input
      type="checkbox"
      checked={selectedStoryIds.includes(story.id)}
      onChange={() => toggleStory(story.id)}
    />
    <span className="text-sm">{story.title}</span>
  </label>
))}
```

**Problem:** `selectedStoryIds.includes(story.id)` is O(n) lookup called for each story in the render. For large story lists, this is inefficient.

**Recommendation:**
```typescript
// Convert to Set for O(1) lookup
const selectedStorySet = useMemo(
  () => new Set(selectedStoryIds), 
  [selectedStoryIds]
)

// Then in render:
<input
  type="checkbox"
  checked={selectedStorySet.has(story.id)}
  onChange={() => toggleStory(story.id)}
/>
```

**Also apply to:**
- `CreateProfileForm` (lines 185-198)

#### Issue 15: No debouncing on controlled inputs
**File:** `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`  
**Lines:** 133-139, 152-158

```typescript
<input
  type="text"
  value={title}
  onChange={(e) => setTitle(e.target.value)}
/>

<textarea
  value={responses[prompt.key] || ''}
  onChange={(e) => handleResponseChange(prompt.key, e.target.value)}
/>
```

**Problem:** Every keystroke triggers a state update, which triggers the auto-save effect dependency check. While the actual save is debounced, the state updates themselves could be optimized.

**Recommendation:** This is actually fine as-is since the auto-save is properly debounced. However, if you notice performance issues:
```typescript
import { useDeferredValue } from 'react'

const [localTitle, setLocalTitle] = useState(title)
const deferredTitle = useDeferredValue(localTitle)

useEffect(() => {
  setTitle(deferredTitle)
}, [deferredTitle])
```

#### Issue 16: Missing React.memo for list items
**File:** `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`  
**Lines:** 100-136

```typescript
function StoryViewer({ story }: { story: WorkStory }) {
  // ... component logic
}
```

**Problem:** When rendering a list of stories, each story re-renders even if only one changed.

**Recommendation:**
```typescript
const StoryViewer = memo(({ story }: { story: WorkStory }) => {
  // ... component logic
})
```

---

## 6. Security Considerations

### ‚úÖ Strengths

**Excellent security practices in AuthContext:**
- Error message sanitization prevents email enumeration
- Type validation for metadata extraction
- Proper handling of auth state

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 17: No input sanitization for user-provided content
**Files:**
- `StoryEditor.tsx`: User input directly stored
- `ProfileManager.tsx`: Profile names not sanitized

**Problem:** While React escapes content by default, there's no validation on input length, characters, or content before storing in the database.

**Recommendation:**
```typescript
// src/lib/validation.ts
export const VALIDATION_RULES = {
  profileName: {
    minLength: 1,
    maxLength: 100,
    pattern: /^[\w\s\-,.']+$/,
  },
  storyTitle: {
    minLength: 1,
    maxLength: 200,
  },
  storyResponse: {
    maxLength: 5000,
  },
} as const

export function validateProfileName(name: string): string | null {
  const trimmed = name.trim()
  if (trimmed.length < VALIDATION_RULES.profileName.minLength) {
    return 'Profile name is required'
  }
  if (trimmed.length > VALIDATION_RULES.profileName.maxLength) {
    return `Profile name must be ${VALIDATION_RULES.profileName.maxLength} characters or less`
  }
  if (!VALIDATION_RULES.profileName.pattern.test(trimmed)) {
    return 'Profile name contains invalid characters'
  }
  return null
}

// Use in form validation:
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault()
  
  const validationError = validateProfileName(name)
  if (validationError) {
    showAlert(validationError, 'Validation Error')
    return
  }
  
  // ... proceed with creation
}
```

#### Issue 18: No rate limiting on client side
**Files:** All mutation hooks

**Problem:** No client-side prevention of rapid-fire submissions (e.g., double-clicking create button).

**Recommendation:** Rely on mutation state:
```typescript
<button
  type="submit"
  disabled={createProfile.isPending || !name.trim()}
  className="..."
>
  {createProfile.isPending ? 'Creating...' : 'Create Profile'}
</button>
```

This is already implemented correctly in most places, but ensure consistency across all forms.

---

## 7. Code Smells & Anti-Patterns

### ‚ö†Ô∏è Issues & Recommendations

#### Issue 19: Inconsistent null checks
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Line:** 132

```typescript
if (!name.trim()) {
  showAlert('Please enter a profile name.', 'Error')
  return
}
```

**File:** `/Users/ryan/projects/level2bio/src/pages/Dashboard.tsx`  
**Line:** 18

```typescript
{user?.name || authUser?.name || 'User'}
```

**Problem:** Inconsistent use of optional chaining vs explicit checks.

**Recommendation:** Establish consistent patterns:
```typescript
// For validation:
if (!name?.trim()) { ... }

// For display:
const displayName = user?.name ?? authUser?.name ?? 'User'
```

#### Issue 20: Boolean logic smell
**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts`  
**Lines:** 28-30

```typescript
if (!profiles || profiles.length === 0) {
  return []
}
```

**Problem:** Can be simplified.

**Recommendation:**
```typescript
if (!profiles?.length) {
  return []
}
```

#### Issue 21: Mixed string concatenation and template literals
**File:** `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`  
**Lines:** 62, 419

```typescript
{user.name.split(' ')[0]} has shared ...
{profile.stories.length} {profile.stories.length === 1 ? 'story' : 'stories'}
```

**Recommendation:** Use consistent approach and create helper:
```typescript
// src/lib/formatting.ts
export function pluralize(count: number, singular: string, plural?: string): string {
  return `${count} ${count === 1 ? singular : (plural ?? `${singular}s`)}`
}

// Usage:
{pluralize(profile.stories.length, 'story', 'stories')}
```

#### Issue 22: Inline styles and className concatenation
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 435-437

```typescript
className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 ${
  profile.is_active ? 'bg-blue-600' : 'bg-gray-200'
}`}
```

**Problem:** Long, hard-to-read className strings.

**Recommendation:** Use a utility like `clsx` or `classnames`:
```typescript
import clsx from 'clsx'

className={clsx(
  'relative inline-flex h-6 w-11 items-center rounded-full',
  'transition-colors focus:outline-none focus:ring-2',
  'focus:ring-blue-500 focus:ring-offset-2',
  profile.is_active ? 'bg-blue-600' : 'bg-gray-200'
)}
```

---

## 8. Missing Best Practices

#### Issue 23: No loading states for mutations in some components
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 291-302

```typescript
const handleToggle = async () => {
  try {
    await toggleProfile.mutateAsync({...})
  } catch (err) {
    console.error('Failed to toggle profile:', err)
    showAlert('Failed to update profile. Please try again.', 'Error')
  }
}
```

**Problem:** The button doesn't show loading state during the toggle operation, though the mutation has `isPending`.

**Recommendation:**
```typescript
<button
  onClick={handleToggle}
  disabled={toggleProfile.isPending}
  className={...}
>
  {/* Show loading indicator */}
  {toggleProfile.isPending ? (
    <span>Updating...</span>
  ) : (
    <span>{profile.is_active ? 'Active' : 'Inactive'}</span>
  )}
</button>
```

#### Issue 24: No data fetching error states
**File:** `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`  
**Lines:** 19-32

```typescript
const { data: profiles, isLoading } = useProfiles(userId)

if (isLoading) {
  return <div>Loading profiles...</div>
}
```

**Problem:** The `error` state from the query is ignored. If the fetch fails, the component shows nothing.

**Recommendation:**
```typescript
const { data: profiles, isLoading, error } = useProfiles(userId)

if (isLoading) {
  return <LoadingState message="Loading profiles..." />
}

if (error) {
  return <ErrorState message="Failed to load profiles" onRetry={() => refetch()} />
}
```

#### Issue 25: Missing accessibility attributes
**Files:** Multiple component files

**Problem:** Several interactive elements lack proper ARIA labels and keyboard support.

**Examples:**
- Video iframes lack proper titles (though StoryEditor has one on line 187)
- Checkbox lists could benefit from fieldset/legend
- Custom toggle switch has `role="switch"` (good!) but could use `aria-label`

**Recommendation:**
```typescript
// For toggle switch
<button
  onClick={handleToggle}
  className="..."
  role="switch"
  aria-checked={profile.is_active}
  aria-label={`${profile.is_active ? 'Deactivate' : 'Activate'} profile`}
>
```

---

## 9. Testing Considerations

### Missing Test Support

**Problem:** No evidence of test files or test-friendly patterns:
- No test IDs on elements
- No exported prop types for testing
- Complex logic mixed with UI

**Recommendation:**

1. **Add test IDs:**
```typescript
<button data-testid="create-profile-submit">
  Create Profile
</button>
```

2. **Export prop interfaces:**
```typescript
export interface ProfileCardProps { ... }
```

3. **Extract business logic to testable hooks:**
```typescript
// ProfileCard.tsx
export function useProfileCardActions(profile: Profile) {
  const toggleProfile = useToggleProfile()
  const updateProfile = useUpdateProfile()
  
  const handleToggle = useCallback(async () => {
    await toggleProfile.mutateAsync(...)
  }, [profile.id])
  
  return { handleToggle, isLoading: toggleProfile.isPending }
}

// ProfileCard.test.ts
test('useProfileCardActions toggles profile', async () => {
  const { result } = renderHook(() => useProfileCardActions(mockProfile))
  await act(() => result.current.handleToggle())
  expect(mockToggleMutation).toHaveBeenCalled()
})
```

---

## 10. Documentation & Comments

### ‚ö†Ô∏è Issues

**Problem:** Very minimal inline documentation:
- No JSDoc comments on public functions/hooks
- No README in feature directories
- Complex algorithms (like YouTube ID extraction) lack explanation

**Recommendation:**

```typescript
/**
 * Fetches all profiles for a given user with their associated stories.
 * 
 * @param userId - The user ID to fetch profiles for
 * @returns Query result containing profiles with embedded stories, ordered by creation date
 * 
 * @example
 * ```tsx
 * const { data: profiles, isLoading } = useProfiles(user.id)
 * ```
 */
export function useProfiles(userId: string | undefined) {
  // ...
}

/**
 * Extracts YouTube video ID from various URL formats.
 * Supports:
 * - Standard URLs: youtube.com/watch?v=...
 * - Short URLs: youtu.be/...
 * - Embed URLs: youtube.com/embed/...
 * - Raw video IDs (11 characters)
 * 
 * @param url - YouTube URL or video ID
 * @returns Extracted video ID or null if invalid
 */
export function extractYouTubeId(url: string): string | null {
  // ...
}
```

---

## Summary of Priority Issues

### üî¥ High Priority (Fix Soon)
1. **Type assertions without validation** (Issues #4, #5, #7) - Runtime safety
2. **Missing error tracking** (Issue #11) - Production debugging
3. **No error boundaries** (Issue #13) - User experience
4. **Missing error states in queries** (Issue #24) - User experience
5. **Input validation** (Issue #17) - Data integrity

### üü° Medium Priority (Plan for Next Sprint)
6. **Component size** (Issue #3) - Maintainability
7. **Code duplication** (Issues #8, #9) - DRY principle
8. **Performance optimizations** (Issues #14, #16) - Scalability
9. **Inconsistent patterns** (Issues #19, #20, #21) - Code quality
10. **Missing loading states** (Issue #23) - User experience

### üü¢ Low Priority (Technical Debt)
11. **Export prop types** (Issue #6) - Testing
12. **Extract magic numbers** (Issue #10) - Maintainability
13. **Accessibility improvements** (Issue #25) - Inclusivity
14. **Documentation** (Section #10) - Developer experience
15. **Testing infrastructure** (Section #9) - Quality assurance

---

## Positive Patterns to Maintain

1. ‚úÖ Consistent use of React Query for server state
2. ‚úÖ Feature-based code organization
3. ‚úÖ Custom hooks for business logic
4. ‚úÖ Type safety with TypeScript (where properly applied)
5. ‚úÖ Proper error sanitization in auth flows
6. ‚úÖ Good separation of queries and mutations
7. ‚úÖ Consistent naming conventions
8. ‚úÖ Use of absolute imports with `@/` alias

---

This review found **25 specific issues** across the codebase. Overall, the code demonstrates solid React and TypeScript fundamentals with room for improvement in type safety, error handling, and code organization. The architecture is sound and ready for scaling with the recommended improvements.
