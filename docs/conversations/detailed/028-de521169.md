# Conversation: refactored-tumbling-rivest

**Session ID:** `71bd051f-2d7f-45c2-9977-b88b01287b69`
**Agent ID:** `de521169`
**Started:** 2025-12-03T00:07:47.667Z
**Ended:** 2025-12-03T00:09:17.854Z
**Duration:** 2 minutes

---

### ðŸ¤– Assistant
*6:07:47 PM*

I'll conduct a thorough security audit focusing on access control and authorization logic. Let me start by exploring the codebase structure and identifying critical areas.

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
find /Users/ryan/projects/level2bio -type f -name "*.tsx" -o -name "*.ts" | grep -E "(hook|mutation|auth|route|profile|story)" | head -20
```


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `**/*.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `**/*.ts`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/src/lib/utils.ts`
- `/Users/ryan/projects/level2bio/src/types/index.ts`
- `/Users/ryan/projects/level2bio/src/vite-env.d.ts`
- `/Users/ryan/projects/level2bio/src/features/stories/templates.ts`
- `/Users/ryan/projects/level2bio/src/lib/supabase.ts`
- `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStories.ts`
- `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLink.ts`
- `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLinkMutations.ts`
- `/Users/ryan/projects/level2bio/src/features/profile/index.ts`
- `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts`
... and 12 more


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/src/main.tsx`
- `/Users/ryan/projects/level2bio/src/pages/NotFound.tsx`
- `/Users/ryan/projects/level2bio/src/features/auth/components/ProtectedRoute.tsx`
- `/Users/ryan/projects/level2bio/src/features/auth/components/LoginButton.tsx`
- `/Users/ryan/projects/level2bio/src/components/ErrorBoundary.tsx`
- `/Users/ryan/projects/level2bio/src/features/auth/components/EmailAuthForm.tsx`
- `/Users/ryan/projects/level2bio/src/components/Dialog.tsx`
- `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`
- `/Users/ryan/projects/level2bio/src/features/stories/components/AssetUploader.tsx`
- `/Users/ryan/projects/level2bio/src/App.tsx`
... and 17 more


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/node_modules/@types/node/async_hooks.d.ts
/Users/ryan/projects/level2bio/node_modules/@types/node/perf_hooks.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/react-query/build/legacy/mutationOptions.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/react-query/build/modern/mutationOptions.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/react-query/src/mutationOptions.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/query-core/build/legacy/mutationObserver.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/query-core/build/legacy/mutation.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/query-core/build/legacy/mutationCache.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/query-core/build/modern/mutationObserver.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/query-core/build/modern/mutation.d.ts
/Users/ryan/projects/level2bio/node_modules/@tanstack/query-core/build/modern/mutatio
... (truncated)
```


</details>

### ðŸ¤– Assistant
*6:07:51 PM*

Good. Now let me examine the critical files systematically. Let me start with route protection and then dive into mutations.

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/App.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/auth/components/ProtectedRoute.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx`


</details>

### ðŸ¤– Assistant
*6:07:54 PM*

Now let me examine the story mutations and profile mutations to check ownership validation:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStories.ts`


</details>

### ðŸ¤– Assistant
*6:07:58 PM*

Now let me check the profile hooks and public profile access:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/pages/PublicProfilePage.tsx`


</details>

### ðŸ¤– Assistant
*6:08:03 PM*

Now let me check the share link mutations and asset upload:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLinkMutations.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useAssetUpload.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/components/StoryEditor.tsx`


</details>

### ðŸ¤– Assistant
*6:08:06 PM*

Now let me check the ProfileManager component and examine how permissions are checked:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileManager.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
grep -r "eq('user_id'" /Users/ryan/projects/level2bio/src --include="*.ts" --include="*.tsx" | head -20
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/src/features/stories/hooks/useStories.ts:        .eq('user_id', userId)
/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts:        .eq('user_id', userId)
/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts:        .eq('user_id', userId)
/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLink.ts:        .eq('user_id', userId)
```


</details>

### ðŸ¤– Assistant
*6:08:10 PM*

Let me check the database types and look for RLS policies:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/types/database.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `**/*.sql`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/supabase/migrations/001_initial_schema.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/002_fix_auth_id.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/003_fix_rls_recursion.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/004_remove_auth_id.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/005_profiles.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/006_remove_story_status.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/008_storage_buckets.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/009_fix_profile_enumeration.sql`


</details>

### ðŸ¤– Assistant
*6:08:14 PM*

Let me check the RLS policies in the migrations:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/001_initial_schema.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/005_profiles.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/009_fix_profile_enumeration.sql`


</details>

### ðŸ¤– Assistant
*6:08:16 PM*

Now let me check for the ProfileCard component and see how ownership is validated during edits:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
grep -r "authUser\|auth.uid()" /Users/ryan/projects/level2bio/src --include="*.tsx" --include="*.ts" | grep -v node_modules | head -30
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/src/features/auth/components/EmailAuthForm.tsx:      // onAuthStateChange will handle the redirect via authUser state
/Users/ryan/projects/level2bio/src/features/auth/components/ProtectedRoute.tsx:  const { authUser, isLoading } = useAuth()
/Users/ryan/projects/level2bio/src/features/auth/components/ProtectedRoute.tsx:  if (!authUser) {
/Users/ryan/projects/level2bio/src/features/auth/components/AuthForm.tsx:      // onAuthStateChange will handle the redirect via authUser state
/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx:  authUser: AuthUser | null
/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx:  const [authUser, setAuthUser] = useState<AuthUser | null>(null)
/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx:  const syncUserRecord = useCallback(async (authUser: AuthUser): Promise<User | null> => {
/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx:        .eq('id', authUser.id)
/Users/rya
... (truncated)
```


</details>

### ðŸ¤– Assistant
*6:08:20 PM*

Let me check the StoryEditorPage to see how it validates story ownership:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/pages/StoryEditorPage.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
grep -r "can add a story to.*profile\|add.*profile.*story" /Users/ryan/projects/level2bio/src --include="*.tsx" --include="*.ts"
```


</details>

### ðŸ¤– Assistant
*6:08:24 PM*

Let me search for the CreateProfileForm to understand story selection logic:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/components/CreateProfileForm.tsx`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
grep -rn "profile_stories\|addStoriesToProfile\|storyIds" /Users/ryan/projects/level2bio/src --include="*.tsx" --include="*.ts" | grep -v node_modules | head -20
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/src/types/database.ts:189:      profile_stories: {
/Users/ryan/projects/level2bio/src/types/database.ts:210:            foreignKeyName: 'profile_stories_profile_id_fkey'
/Users/ryan/projects/level2bio/src/types/database.ts:216:            foreignKeyName: 'profile_stories_work_story_id_fkey'
/Users/ryan/projects/level2bio/src/types/database.ts:249:      get_public_profile_stories: {
/Users/ryan/projects/level2bio/src/types/database.ts:290:export type ProfileStory = Database['public']['Tables']['profile_stories']['Row']
/Users/ryan/projects/level2bio/src/types/database.ts:291:export type ProfileStoryInsert = Database['public']['Tables']['profile_stories']['Insert']
/Users/ryan/projects/level2bio/src/types/database.ts:292:export type ProfileStoryUpdate = Database['public']['Tables']['profile_stories']['Update']
/Users/ryan/projects/level2bio/src/features/profile/components/CreateProfileForm.tsx:46:        storyIds: selectedStoryIds,
/Users/ryan/projects/leve
... (truncated)
```


</details>

### ðŸ¤– Assistant
*6:08:27 PM*

Now let me check the latest migrations to see if there are any more security considerations:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/008_storage_buckets.sql`


</details>

### ðŸ¤– Assistant
*6:08:30 PM*

Now let me check the increment_profile_view function more carefully and look at the share link hook:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLink.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
grep -rn "client\|supabase\|mutateAsync" /Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx | head -15
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:65:      await toggleProfile.mutateAsync({
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:96:          await regenerateToken.mutateAsync({ profileId: profile.id, userId })
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:114:          await deleteProfile.mutateAsync({ profileId: profile.id, userId })
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:125:      await updateStories.mutateAsync({
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:161:      await updateProfile.mutateAsync({
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:175:      await updateProfile.mutateAsync({
/Users/ryan/projects/level2bio/src/features/profile/components/ProfileCard.tsx:206:      await updateProfile.mutateAsync({
/Users/ryan/projects/level2bio/src/features/profile/components/Pr
... (truncated)
```


</details>

### ðŸ¤– Assistant
*6:08:33 PM*

Now let me check if there's any verification that the story IDs belong to the user who owns the profile:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
grep -A 10 "useUpdateProfileStories" /Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts | grep -A 10 "mutationFn"
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
    mutationFn: async ({ profileId, storyIds }: UpdateProfileStoriesInput) => {
      // Delete existing profile_stories
      const { error: deleteError } = await supabase
        .from('profile_stories')
        .delete()
        .eq('profile_id', profileId)
```


</details>

### ðŸ¤– Assistant
*6:08:36 PM*

Perfect. Now I have enough information to compile a comprehensive security audit. Let me create a detailed report:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
git log --oneline | head -20
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
c6dba62 feat: Update logo and add favicon.ico
50e8a7c feat: Add Level2 logo to site
3ec3f82 fix: Update robots.txt to not block homepage indexing
7526f22 feat: Security hardening and Lighthouse improvements
ca89414 docs: Add Claude Code conversation info and token usage to README
3a25d8d feat: Replace chat version with single user-prompts.md
3259f2f feat: Add chat-only version of conversation exports
3913be1 fix: Show note when context was compacted instead of hiding
8f7344d fix: Filter out context continuation summaries from user messages
1ac15e4 fix: Change user icon to ðŸ‘¤
7d01fe6 fix: Improve conversation export formatting
7deb46b feat: Add conversation export script
c77c434 docs: Update hosting to Vercel, mark as shipped
4e4b652 chore: Add Vercel configuration and fix lint errors
9a0029b feat: Add deploy command for Supabase/Vercel deployment
a7540e4 docs: Update documentation with implementation progress
8c41035 Fix best practices, security, and performance issues
7259f87 Shorten 
... (truncated)
```


</details>

### ðŸ¤– Assistant
*6:09:17 PM*

Now I have a comprehensive understanding of the codebase. Let me compile the security audit report:

## Security Audit Report: Level2.bio

Based on a thorough analysis of the authorization and access control logic, I've identified the following vulnerabilities and security considerations:

---

### CRITICAL VULNERABILITIES

#### 1. **Story Ownership Bypass via Profile Story Association (CRITICAL)**

**Vulnerability:**
In `useUpdateProfileStories()` (lines 245-292 in `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts`), there is NO validation that the story IDs being added to a profile belong to the authenticated user.

**Attack Scenario:**
1. User A is authenticated and owns Profile ID `prof-123`
2. User B creates a story with ID `story-456` (belongs to User B)
3. User A calls `updateProfile.mutateAsync()` with `storyIds: ['story-456']`
4. The mutation accepts ANY story IDs without checking ownership
5. Result: User A's profile can now include User B's private stories without permission

**Code Evidence:**
```typescript
// useProfileMutations.ts, lines 245-275
export function useUpdateProfileStories() {
  return useMutation({
    mutationFn: async ({ profileId, storyIds }: UpdateProfileStoriesInput) => {
      // NO CHECK: Does profileId belong to current user?
      // NO CHECK: Do storyIds belong to current user?
      
      // Delete existing profile_stories
      const { error: deleteError } = await supabase
        .from('profile_stories')
        .delete()
        .eq('profile_id', profileId)  // Only filters by profile ID

      if (deleteError) throw new Error(...)

      // Insert new profile_stories with ANY storyIds
      if (storyIds.length > 0) {
        const profileStories = storyIds.map((storyId, index) => ({
          profile_id: profileId,
          work_story_id: storyId,  // No validation that user owns this story
          display_order: index,
        }))

        const { error: insertError } = await supabase
          .from('profile_stories')
          .insert(profileStories)
      }
    }
  })
}
```

**Why RLS Doesn't Catch This:**
The RLS policy on `profile_stories` (migration 005, lines 106-114) only checks that the user owns the profile:
```sql
-- Users can insert own profile_stories
CREATE POLICY "users can insert own profile_stories"
  ON profile_stories FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = profile_stories.profile_id
      AND profiles.user_id = auth.uid()  -- Checks profile ownership
    )
  );
```

The foreign key constraint on `work_story_id` only enforces referential integrity, not ownership. A valid story ID from any user passes the constraint.

**Severity:** CRITICAL

**Recommended Fix:**
Add server-side validation before inserting profile_stories:
```typescript
mutationFn: async ({ profileId, storyIds }: UpdateProfileStoriesInput) => {
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) throw new Error('Not authenticated')
  
  // Verify all stories belong to current user
  const { data: stories } = await supabase
    .from('work_stories')
    .select('id')
    .eq('user_id', session.user.id)
    .in('id', storyIds)
  
  if (stories?.length !== storyIds.length) {
    throw new Error('One or more stories do not belong to you')
  }
  
  // Also verify profile belongs to current user
  const { data: profile } = await supabase
    .from('profiles')
    .select('user_id')
    .eq('id', profileId)
    .single()
  
  if (profile?.user_id !== session.user.id) {
    throw new Error('You do not own this profile')
  }
  
  // Now safe to proceed...
}
```

Alternatively (better approach), create a server function to validate all constraints at once.

---

#### 2. **Missing Ownership Validation in Story Mutations (CRITICAL)**

**Vulnerability:**
In `useUpdateStory()` and `useDeleteStory()` (lines 64-109 in `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts`), the mutations accept a story `id` parameter but do NOT validate that the authenticated user owns that story in the mutation function itselfâ€”they rely entirely on RLS.

**Attack Scenario:**
1. User A and User B both authenticated
2. User B directly calls: `updateStory.mutateAsync({ id: 'user-a-story-id', updates: {...} })`
3. RLS should block this, but if there's a timing issue or the client has cached auth context, the mutation proceeds
4. Supabase RLS blocks it, but this is relying on a single line of defense

**Code Evidence:**
```typescript
// useStoryMutations.ts, lines 64-87
export function useUpdateStory() {
  return useMutation({
    mutationFn: async ({ id, updates }: UpdateStoryInput) => {
      // NO CLIENT-SIDE OWNERSHIP CHECK
      // Relying 100% on RLS to block unauthorized updates
      
      const { data, error } = await supabase
        .from('work_stories')
        .update({ ...updates, updated_at: new Date().toISOString() })
        .eq('id', id)  // Only filters by ID, not ownership
        .select()
        .single()

      if (error) throw new Error(...)
      return data
    }
  })
}
```

**Why This Matters:**
While RLS will ultimately prevent the database mutation, this violates the "security-first" principle mentioned in CLAUDE.md. The mutation should validate ownership at the application layer as a defense-in-depth measure.

**Severity:** HIGH (RLS protects, but missing client-side validation)

**Recommended Fix:**
Fetch the story and verify ownership before allowing mutations:
```typescript
mutationFn: async ({ id, updates }: UpdateStoryInput) => {
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) throw new Error('Not authenticated')
  
  // Verify ownership before updating
  const { data: story } = await supabase
    .from('work_stories')
    .select('user_id')
    .eq('id', id)
    .single()
  
  if (story?.user_id !== session.user.id) {
    throw new Error('Unauthorized')
  }
  
  // Safe to proceed with update
  const { data, error } = await supabase
    .from('work_stories')
    .update({ ...updates, updated_at: new Date().toISOString() })
    .eq('id', id)
    .select()
    .single()
  
  if (error) throw new Error(...)
  return data
}
```

---

#### 3. **Missing Ownership Validation in Profile Mutations (CRITICAL)**

**Vulnerability:**
All profile mutations (`useUpdateProfile`, `useToggleProfile`, `useRegenerateProfileToken`, `useDeleteProfile`) accept a `profileId` parameter without validating that the authenticated user owns it within the mutation function.

**Code Evidence:**
```typescript
// useProfileMutations.ts, lines 95-137
export function useUpdateProfile() {
  return useMutation({
    mutationFn: async ({
      profileId,
      name,
      headline,
      bio,
      expiresAt,
    }: UpdateProfileInput) => {
      // NO OWNERSHIP CHECK - relying 100% on RLS
      
      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('id', profileId)  // Only filters by ID
        .select()
        .single()
    }
  })
}
```

**Attack Scenario:**
User A could craft a request to update Profile ID from User B by calling mutation with User B's profile ID.

**Severity:** CRITICAL (RLS protects, but missing defense-in-depth)

**Recommended Fix:**
Add ownership checks to all profile mutations (same pattern as stories above).

---

#### 4. **No Validation That Stories in Profile Belong to Profile Owner (CRITICAL)**

**Vulnerability:**
Related to vulnerability #1, but distinct: when creating a profile with initial stories (`useCreateProfile`, lines 30-84), there's no validation.

**Attack Scenario:**
1. User A calls: `createProfile.mutateAsync({ userId: 'user-a-id', storyIds: ['user-b-story-id'] })`
2. The mutation creates a profile owned by User A
3. But adds User B's story to User A's profile without checking
4. Result: User A's public profile can expose User B's stories

**Code Evidence:**
```typescript
// useProfileMutations.ts, lines 60-74
if (storyIds.length > 0) {
  const profileStories = storyIds.map((storyId, index) => ({
    profile_id: profile.id,
    work_story_id: storyId,  // NO VALIDATION that user owns this story
    display_order: index,
  }))

  const { error: psError } = await supabase
    .from('profile_stories')
    .insert(profileStories)
}
```

**Severity:** CRITICAL

---

### HIGH SEVERITY VULNERABILITIES

#### 5. **Implicit Trust of `userId` Parameter in Mutations (HIGH)**

**Vulnerability:**
Profile and story mutations accept a `userId` parameter from the client, which is used for cache invalidation but also included in the mutation call:

```typescript
// ProfileCard.tsx, line 65
await toggleProfile.mutateAsync({
  profileId: profile.id,
  isActive: !profile.is_active,
  userId,  // Passed by client - not verified!
})
```

While the `userId` is used only for cache invalidation (`queryKey`), this is a trust violation. The client shouldn't be telling the server whose operation to perform.

**Severity:** HIGH

**Recommended Fix:**
Extract the authenticated user ID from the session inside mutations, not from client parameters:
```typescript
mutationFn: async ({ profileId, isActive }: ToggleProfileInput) => {
  const { data: { session } } = await supabase.auth.getSession()
  if (!session) throw new Error('Not authenticated')
  
  // Now use session.user.id, not a parameter
  const userId = session.user.id
  // ... verify ownership ...
}
```

---

#### 6. **Timing Attack on Share Token Lookup (MEDIUM-HIGH)**

**Vulnerability:**
The `get_public_profile` function uses a simple equality check on `share_token`:
```sql
WHERE p.share_token = p_share_token
```

A timing attack could theoretically measure response time to determine if a share token is valid. However, the current implementation mitigates this somewhat by returning an empty result set rather than an error.

**Severity:** MEDIUM-HIGH (Low practical impact, but possible)

**Recommended Fix:**
The SECURITY DEFINER function approach is good. Consider adding a random delay to normalize response times:
```sql
CREATE OR REPLACE FUNCTION get_public_profile(p_share_token TEXT)
...
BEGIN
  -- Add random delay (5-25ms) to prevent timing attacks
  PERFORM pg_sleep(0.005 + random() * 0.02);
  
  RETURN QUERY
  SELECT ... WHERE p.share_token = p_share_token ...
END;
```

---

### MEDIUM SEVERITY ISSUES

#### 7. **Brute Force Token Generation (MEDIUM)**

**Vulnerability:**
Share tokens use 8 characters from a 54-character alphabet:
```typescript
// useProfileMutations.ts, lines 6-14
const TOKEN_CHARS = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz'
const TOKEN_LENGTH = 8

function generateToken(): string {
  const array = new Uint8Array(TOKEN_LENGTH)
  crypto.getRandomValues(array)
  return Array.from(array, (byte) => TOKEN_CHARS[byte % TOKEN_CHARS.length]).join('')
}
```

This provides ~43 bits of entropy (54^8 â‰ˆ 2.3 Ã— 10^14 possible tokens). While this seems reasonable, in a production environment with many users, tokens could be brute-forced with moderate effort over time.

**Calculation:**
- 54^8 = 2.3 trillion possible tokens
- If a attacker can make 10,000 requests/sec: ~265 days to exhaustively search
- Practical attack: with 1 million requests/sec: ~27 days

**Severity:** MEDIUM (Rate limiting can mitigate)

**Recommended Fix:**
1. Use larger token (16 characters instead of 8)
2. Implement rate limiting on `get_public_profile()` calls
3. Monitor for token enumeration (many 404s from similar token patterns)

---

#### 8. **Profile Expiration Can Be Bypassed via `get_public_profile()` Call Timing (LOW-MEDIUM)**

**Vulnerability:**
The `get_public_profile()` and `get_public_profile_stories()` functions check expiration at call time:
```sql
WHERE p.share_token = p_share_token
  AND p.is_active = true
  AND (p.expires_at IS NULL OR p.expires_at > now());
```

If a profile expires between the two function calls, a race condition could occur (unlikely but possible):
1. Call `get_public_profile()` at 11:59:59 â†’ Returns profile data
2. Profile expires at 12:00:00
3. Call `get_public_profile_stories()` at 12:00:01 â†’ Returns stories (should be empty)

**Severity:** LOW-MEDIUM (Mitigated by frontend showing "expired")

**Recommended Fix:**
Combine both queries into a single function call to atomically check expiration once.

---

### LOW SEVERITY / BEST PRACTICES

#### 9. **Client-Side Route Protection Without Ownership Check (LOW)**

**Vulnerability:**
The `StoryEditorPage` shows a "Story not found" message when a story can't be loaded, but doesn't explicitly show that it's an authorization error vs. a 404. This could be used to enumerate valid story IDs:

```typescript
// StoryEditorPage.tsx, lines 91-106
if (!isNew && (error || !story)) {
  return (
    <div>
      <h1>Story not found</h1>
      <p>This story doesn't exist or you don't have access to it.</p>
    </div>
  )
}
```

An attacker could iterate story IDs and see which ones fail differently.

**Severity:** LOW (Information disclosure only)

**Recommended Fix:**
This is actually good as-isâ€”it doesn't leak whether the story exists or the user lacks permission. Keep the generic message.

---

#### 10. **No Rate Limiting on Mutations (LOW)**

**Vulnerability:**
There's no rate limiting on profile creation, story creation, or asset uploads. A malicious user could spam create operations.

**Severity:** LOW (But important for prod)

**Recommended Fix:**
Implement rate limiting:
- Per-user limits on story/profile creation
- Per-user limits on asset uploads
- Per-IP limits on public profile views

---

#### 11. **Asset Upload Path Validation Incomplete (LOW)**

**Vulnerability:**
In `useAssetUpload.ts`, line 190:
```typescript
const expectedPrefix = `${userId}/${storyId}/`
if (!filePath.startsWith(expectedPrefix)) {
  throw new Error('Unauthorized: Cannot delete files outside your story')
}
```

This checks the path prefix, but only AFTER extracting from the public URL. If the storage bucket path structure changes, this could fail silently.

**Severity:** LOW (Mitigated by storage RLS policies)

**Recommended Fix:**
Store the original file path in the asset metadata rather than reconstructing it:
```typescript
// In StoryEditor.tsx, when saving assets
assets: assets.map(a => ({
  ...a,
  originalPath: filePath,  // Store at upload time
}))
```

---

#### 12. **Public Profile Expiration Not Clearly Communicated (LOW)**

**Vulnerability:**
When a profile expires, viewers see a "Not Available" message, but there's no explanation of why (expired vs. deleted vs. deactivated).

**Severity:** LOW (UX issue, not a security issue)

---

## SUMMARY TABLE

| # | Vulnerability | Severity | Status | Type |
|---|---|---|---|---|
| 1 | Story ownership bypass in profile association | CRITICAL | Open | Logic flaw |
| 2 | Missing ownership validation in story mutations | CRITICAL | Open | Defense-in-depth |
| 3 | Missing ownership validation in profile mutations | CRITICAL | Open | Defense-in-depth |
| 4 | No validation stories belong to profile owner | CRITICAL | Open | Logic flaw |
| 5 | Implicit trust of userId parameter | HIGH | Open | Trust violation |
| 6 | Timing attack on share token lookup | MEDIUM-HIGH | Mitigated | Cryptography |
| 7 | Brute force token generation | MEDIUM | Mitigated | Entropy |
| 8 | Profile expiration race condition | LOW-MEDIUM | Minor | Race condition |
| 9 | Story enumeration via error messages | LOW | Good | Info disclosure |
| 10 | No rate limiting | LOW | Design | DoS |
| 11 | Asset upload path validation | LOW | Mitigated | Path traversal |
| 12 | Expired profile UX | LOW | Minor | UX |

---

## WHAT'S WORKING WELL

1. **RLS Policies**: Well-designed row-level security policies prevent unauthorized data access at the database layer
2. **SECURITY DEFINER Functions**: Using `get_public_profile()` and `get_public_profile_stories()` functions prevents enumeration attacks
3. **Profile Enumeration Fix**: Migration 009 correctly removes public SELECT policies on profiles
4. **Storage RLS**: Storage policies correctly validate user ownership of uploaded files
5. **File Signature Validation**: Magic number validation prevents file type spoofing
6. **Error Message Sanitization**: Auth error messages prevent email enumeration

---

## PRIORITY REMEDIATION ORDER

1. **IMMEDIATE**: Fix story ownership validation in `useUpdateProfileStories()` (#1)
2. **IMMEDIATE**: Add ownership checks to all profile mutations (#3, #5)
3. **IMMEDIATE**: Validate story ownership when adding to profiles (#4)
4. **HIGH**: Add ownership checks to story mutations (#2)
5. **HIGH**: Implement rate limiting on mutations
6. **MEDIUM**: Increase token size to 16 characters
7. **MEDIUM**: Add timing attack mitigation to token lookup
8. **LOW**: Improve error messaging for expired profiles
