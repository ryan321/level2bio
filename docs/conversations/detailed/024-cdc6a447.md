# Conversation: refactored-tumbling-rivest

**Session ID:** `71bd051f-2d7f-45c2-9977-b88b01287b69`
**Agent ID:** `cdc6a447`
**Started:** 2025-12-03T00:07:46.252Z
**Ended:** 2025-12-03T00:09:30.482Z
**Duration:** 2 minutes

---

### ðŸ¤– Assistant
*6:07:46 PM*

I'll conduct a thorough security audit of the Supabase RLS policies and database security in this codebase. Let me start by exploring the structure and identifying key areas.

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
find /Users/ryan/projects/level2bio -type f -name "*.sql" | head -20
```


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `supabase/migrations/*.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `src/types/*.ts`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/supabase/migrations/001_initial_schema.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/002_fix_auth_id.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/003_fix_rls_recursion.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/004_remove_auth_id.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/005_profiles.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/006_remove_story_status.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/008_storage_buckets.sql`
- `/Users/ryan/projects/level2bio/supabase/migrations/009_fix_profile_enumeration.sql`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/src/types/index.ts`
- `/Users/ryan/projects/level2bio/src/types/database.ts`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/supabase/migrations/008_storage_buckets.sql
/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql
/Users/ryan/projects/level2bio/supabase/migrations/005_profiles.sql
/Users/ryan/projects/level2bio/supabase/migrations/001_initial_schema.sql
/Users/ryan/projects/level2bio/supabase/migrations/004_remove_auth_id.sql
/Users/ryan/projects/level2bio/supabase/migrations/009_fix_profile_enumeration.sql
/Users/ryan/projects/level2bio/supabase/migrations/006_remove_story_status.sql
/Users/ryan/projects/level2bio/supabase/migrations/002_fix_auth_id.sql
/Users/ryan/projects/level2bio/supabase/migrations/003_fix_rls_recursion.sql
```


</details>

### ðŸ¤– Assistant
*6:07:49 PM*

Now let me read all the migration files in order to understand the complete RLS setup:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/001_initial_schema.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/002_fix_auth_id.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/003_fix_rls_recursion.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/004_remove_auth_id.sql`


</details>

### ðŸ¤– Assistant
*6:07:52 PM*

Now let me read the remaining migrations:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/005_profiles.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/006_remove_story_status.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/008_storage_buckets.sql`


</details>

### ðŸ¤– Assistant
*6:07:55 PM*

Now let me read the last migration and then examine the database types and hooks:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/supabase/migrations/009_fix_profile_enumeration.sql`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/types/database.ts`


</details>

### ðŸ¤– Assistant
*6:08:00 PM*

Now let me find and examine all the hooks that make database queries:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `src/**/*.ts`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/src/lib/utils.ts`
- `/Users/ryan/projects/level2bio/src/types/index.ts`
- `/Users/ryan/projects/level2bio/src/vite-env.d.ts`
- `/Users/ryan/projects/level2bio/src/features/stories/templates.ts`
- `/Users/ryan/projects/level2bio/src/lib/supabase.ts`
- `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStories.ts`
- `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLink.ts`
- `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLinkMutations.ts`
- `/Users/ryan/projects/level2bio/src/features/profile/index.ts`
- `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts`
... and 12 more


</details>

### ðŸ¤– Assistant
*6:08:02 PM*

Let me examine the critical hooks:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStories.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts`


</details>

### ðŸ¤– Assistant
*6:08:05 PM*

Now let me check the mutation hooks:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useStoryMutations.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLinkMutations.ts`


</details>

### ðŸ¤– Assistant
*6:08:08 PM*

Now let me check the asset upload hook and auth setup:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/stories/hooks/useAssetUpload.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/lib/supabase.ts`


</details>

### ðŸ¤– Assistant
*6:08:10 PM*

Now let me check the auth context and any other relevant files:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Glob**
Pattern: `src/features/auth/*.ts`


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

Found files:
- `/Users/ryan/projects/level2bio/src/features/auth/index.ts`


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/auth/index.ts`


</details>

### ðŸ¤– Assistant
*6:08:17 PM*

Let me find the actual AuthContext file:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Bash**
```bash
find /Users/ryan/projects/level2bio/src/features/auth -type f -name "*.tsx" -o -name "*.ts" | head -20
```


</details>

<details>
<summary>ðŸ“¤ Tool Output</summary>

```
/Users/ryan/projects/level2bio/src/features/auth/components/EmailAuthForm.tsx
/Users/ryan/projects/level2bio/src/features/auth/components/ProtectedRoute.tsx
/Users/ryan/projects/level2bio/src/features/auth/components/AuthForm.tsx
/Users/ryan/projects/level2bio/src/features/auth/components/LoginButton.tsx
/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx
/Users/ryan/projects/level2bio/src/features/auth/index.ts
```


</details>

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx`


</details>

### ðŸ¤– Assistant
*6:08:22 PM*

Now let me check the useShareLink hook:

<details>
<summary>ðŸ”§ Tool Calls</summary>

**Tool: Read**
Reading: `/Users/ryan/projects/level2bio/src/features/profile/hooks/useShareLink.ts`


</details>

### ðŸ¤– Assistant
*6:09:30 PM*

Perfect. Now I have a comprehensive understanding of the codebase. Let me create a detailed security audit report.

## SECURITY AUDIT REPORT: Level2.bio Database Security & RLS Policies

---

### EXECUTIVE SUMMARY

The codebase demonstrates **solid security practices** overall with appropriate RLS policies protecting user data. However, I've identified **3 critical issues** and several **medium-risk findings** that require immediate attention. The migration history shows an evolution from vulnerable states to more secure implementations, but some vulnerabilities persist.

---

## FINDINGS

### CRITICAL SEVERITY ISSUES

#### 1. **CRITICAL: User Record Takeover via ID Manipulation in AuthContext**

**File:** `/Users/ryan/projects/level2bio/src/features/auth/AuthContext.tsx` (lines 130-145)

**Vulnerability:**
The `syncUserRecord` function allows updating a user's database `id` field based on email lookup:

```typescript
const { data: updatedUser, error: updateError } = await supabase
  .from('users')
  .update({ id: authUser.id })
  .eq('email', authUser.email)
  .select()
  .single()
```

**How it could be exploited:**
1. Attacker registers with email `victim@example.com`, gets assigned auth ID `attacker-uuid`
2. User creates Supabase auth account with same email `victim@example.com`, gets assigned `victim-uuid`
3. When victim logs in, the code finds their database record by email
4. **It updates that record's id to `victim-uuid`**
5. But if attacker can control the Supabase auth session before the RLS policy check, they could trigger a race condition where their auth ID updates the victim's record

**Attack Scenario:**
The RLS policy checks `auth.uid() = id`, but because `id` is being updated after the user lookup, there's a window for confusion. More critically, the code doesn't validate that the `id` being updated matches the current auth session's UUID.

**Severity:** CRITICAL - Could allow session hijacking or account takeover

**Recommended Fix:**
```typescript
// syncUserRecord function fix
const syncUserRecord = useCallback(async (authUser: AuthUser): Promise<User | null> => {
  try {
    // Only check by ID - never try to merge accounts by email
    const { data: userById } = await supabase
      .from('users')
      .select('*')
      .eq('id', authUser.id)
      .maybeSingle()

    if (userById) {
      return userById
    }

    // If user doesn't exist, create new record (never update existing by email)
    const defaultName = authUser.name !== 'User'
      ? authUser.name
      : authUser.email?.split('@')[0] || 'User'

    const { data: newUser, error: insertError } = await supabase
      .from('users')
      .insert({
        id: authUser.id,  // Must match auth.uid()
        linkedin_id: `auth_${authUser.id}`,
        email: authUser.email,
        name: defaultName,
        headline: authUser.headline,
        profile_photo_url: authUser.profilePhotoUrl,
      })
      .select()
      .single()

    if (insertError) {
      // Account email already exists in different account - this is expected
      // Don't try to "merge" - fail gracefully
      if (insertError.code === '23505') { // unique constraint violation
        logger.warn('Email already exists in system', { email: authUser.email })
        // Return null to trigger error state
        return null
      }
      logger.error('Failed to create user record', insertError)
      return null
    }

    return newUser
  } catch (err) {
    logger.error('Error syncing user record', err)
    return null
  }
}, [])
```

**Why this fix works:**
- Removes the email-based lookup that can cause ID confusion
- Prevents merging accounts by email
- Forces new accounts for duplicate emails
- Ensures `id` always matches `auth.uid()`

---

#### 2. **CRITICAL: Insufficient Profile Access Control in Join Query**

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfiles.ts` (lines 28-38)

**Vulnerability:**
The `useProfiles` hook filters by `user_id` at the application level:

```typescript
const { data: profiles, error } = await supabase
  .from('profiles')
  .select(`
    *,
    profile_stories (
      display_order,
      work_stories (*)
    )
  `)
  .eq('user_id', userId)  // <-- Application enforces this
```

**Problem:** This relies on application-level filtering, not RLS. While RLS policies exist in the database, an attacker could:

1. Modify the `useProfiles` call to request `profiles` without the `.eq('user_id', userId)` filter
2. The RLS policy `"Users can view own profiles"` uses `USING (user_id = auth.uid())`
3. But if the database session is compromised or RLS is disabled, the filter is lost

**Attack Example:**
```typescript
// Attacker modifies the hook:
const { data: profiles } = await supabase
  .from('profiles')
  .select('*')  // No user_id filter!
```

If RLS fails for any reason, attacker gets all profiles.

**Severity:** CRITICAL - Single point of failure; missing defense in depth

**Recommended Fix:**

Add database-level constraints to ensure profiles cannot be accessed without RLS:

```sql
-- In migration: Add NOT NULL constraint and trigger for user_id
ALTER TABLE profiles 
ADD CONSTRAINT profiles_user_id_immutable CHECK (user_id IS NOT NULL);

-- Ensure RLS can never be disabled
ALTER TABLE profiles FORCE ROW LEVEL SECURITY;
ALTER TABLE work_stories FORCE ROW LEVEL SECURITY;
ALTER TABLE profile_stories FORCE ROW LEVEL SECURITY;
ALTER TABLE users FORCE ROW LEVEL SECURITY;

-- Add audit trigger to log access attempts
CREATE TABLE rls_violations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  query_type TEXT NOT NULL,
  attempted_at TIMESTAMPTZ DEFAULT now(),
  details JSONB
);

-- Log when authenticated user tries to access other profiles
CREATE OR REPLACE FUNCTION log_profile_access()
RETURNS TRIGGER AS $$
BEGIN
  IF auth.uid() != NEW.user_id THEN
    INSERT INTO rls_violations (table_name, query_type, details)
    VALUES ('profiles', 'SELECT', jsonb_build_object(
      'requesting_user', auth.uid(),
      'profile_user', NEW.user_id,
      'profile_id', NEW.id
    ));
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

Also in application code, add explicit auth checks:

```typescript
export function useProfiles(userId: string | undefined) {
  const { authUser } = useAuth()
  
  return useQuery({
    queryKey: [...PROFILES_QUERY_KEY, userId],
    queryFn: async (): Promise<ProfileWithStories[]> => {
      if (!userId) return []
      
      // CRITICAL: Verify the requested user matches authenticated user
      if (!authUser || authUser.id !== userId) {
        throw new Error('Unauthorized: Cannot view other users\' profiles')
      }

      const { data: profiles, error } = await supabase
        .from('profiles')
        .select(`...`)
        .eq('user_id', userId)
        // ... rest of query
    },
    enabled: !!userId && !!authUser,
  })
}
```

---

#### 3. **CRITICAL: Unsafe SQL Injection in increment_profile_view SECURITY DEFINER Function**

**File:** `/Users/ryan/projects/level2bio/supabase/migrations/007_security_and_performance.sql` (lines 28-42)

**Vulnerability:**
The `increment_profile_view` function uses a parameter directly in a WHERE clause:

```sql
CREATE OR REPLACE FUNCTION increment_profile_view(p_share_token TEXT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE profiles
  SET
    view_count = view_count + 1,
    last_viewed_at = now()
  WHERE share_token = p_share_token
    AND is_active = true
    AND (expires_at IS NULL OR expires_at > now());
END;
$$;
```

**How it could be exploited:**
While the parameter is bound (not directly interpolated), the SECURITY DEFINER context means this function runs with elevated privileges. An attacker could:

1. Call `increment_profile_view('VALID_TOKEN_OR_ANYTHING')` with specially crafted tokens
2. Because it's SECURITY DEFINER, it bypasses RLS
3. An attacker could enumerate valid share tokens by timing analysis - valid tokens vs invalid tokens might show different performance

**Attack Example:**
```typescript
// Attacker can discover valid tokens through timing
for (const token of generatePossibleTokens()) {
  const startTime = performance.now()
  await supabase.rpc('increment_profile_view', { p_share_token: token })
  const duration = performance.now() - startTime
  
  if (duration > 5) {
    // Token probably valid (took longer to update)
    console.log('Found valid token:', token)
  }
}
```

**Severity:** CRITICAL - Token enumeration + privilege escalation

**Recommended Fix:**

Change to use a function that doesn't expose timing information:

```sql
-- Replace the unsafe function
DROP FUNCTION IF EXISTS increment_profile_view(TEXT);

CREATE OR REPLACE FUNCTION increment_profile_view(p_share_token TEXT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile_id UUID;
BEGIN
  -- First, validate the token exists and is accessible
  SELECT id INTO v_profile_id
  FROM profiles
  WHERE share_token = p_share_token
    AND is_active = true
    AND (expires_at IS NULL OR expires_at > now())
  LIMIT 1;
  
  -- Always try to update (even if invalid token) to prevent timing attacks
  UPDATE profiles
  SET
    view_count = CASE WHEN id = v_profile_id THEN view_count + 1 ELSE view_count END,
    last_viewed_at = CASE WHEN id = v_profile_id THEN now() ELSE last_viewed_at END
  WHERE is_active = true;
END;
$$;

-- Or use constant-time comparison:
CREATE OR REPLACE FUNCTION increment_profile_view(p_share_token TEXT)
RETURNS void
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  UPDATE profiles
  SET
    view_count = view_count + 1,
    last_viewed_at = now()
  WHERE share_token = p_share_token
    AND is_active = true
    AND (expires_at IS NULL OR expires_at > now());
$$;

-- Use a rate limiter in application code instead
```

Better approach - remove the function and use RPC with better controls:

```typescript
// In usePublicProfile hook
void (async () => {
  try {
    // Use a dedicated function that doesn't allow enumeration
    await supabase.rpc('increment_profile_view', { 
      p_share_token: token 
    })
  } catch (err) {
    // Silently fail - don't expose whether token was valid
    logger.error('View count update failed', err)
  }
})()
```

---

### HIGH SEVERITY ISSUES

#### 4. **HIGH: RLS Policy Recursion Risk in profile_stories Join**

**File:** `/Users/ryan/projects/level2bio/supabase/migrations/005_profiles.sql` (lines 95-136)

**Vulnerability:**
The RLS policies for `profile_stories` join through the `profiles` table:

```sql
CREATE POLICY "Users can view own profile_stories"
  ON profile_stories FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM profiles
      WHERE profiles.id = profile_stories.profile_id
      AND profiles.user_id = auth.uid()
    )
  );
```

While migration 003 attempted to fix recursion issues with SECURITY DEFINER functions, these policies still exist and could cause problems if:
1. Someone modifies `profiles` policy to have circular dependencies
2. A query fails in the nested EXISTS check
3. Performance degrades due to N+1 nested RLS checks

**Current State:** The `get_public_profile_stories` function in migration 009 uses SECURITY DEFINER to bypass this, which is correct.

**Severity:** HIGH - Could cause recursion or performance issues

**Recommended Fix:**

Add explicit policy naming and testing:

```sql
-- Add comments to clarify dependency chain
COMMENT ON POLICY "Users can view own profile_stories" ON profile_stories IS 
  'User can see their own profile stories via profiles table (no RLS recursion - profiles.user_id check is direct)';

-- Add test migrations to verify no infinite recursion
-- Test 1: Verify a user can access their own profile_stories
-- Test 2: Verify a user cannot access another user's profile_stories
-- Test 3: Verify public profiles cannot access profile_stories via RLS

-- Explicit policy grant
GRANT SELECT ON profile_stories TO authenticated;
GRANT SELECT ON profile_stories TO anon;
```

---

#### 5. **HIGH: User Update Policy Missing WITH CHECK Clause**

**File:** `/Users/ryan/projects/level2bio/supabase/migrations/004_remove_auth_id.sql` (lines 34-39)

**Vulnerability:**
The user update policy lacks a WITH CHECK clause:

```sql
CREATE POLICY "Users can update own record"
  ON users FOR UPDATE
  USING (auth.uid() = id);
  -- Missing: WITH CHECK (auth.uid() = id)
```

**How it could be exploited:**
An attacker could:
1. Login as themselves (auth.uid() = their-id)
2. Try to update another user's record
3. Without WITH CHECK, the policy only checks if they can *see* the row, not if they can *update* the row
4. Could allow them to change other users' emails, names, etc.

**Attack:**
```typescript
// Attacker's code
await supabase
  .from('users')
  .update({ email: 'attacker@evil.com' })
  .eq('id', 'victim-uuid')  // Not their own ID

// With USING-only policy, this might succeed if victim-uuid exists
```

**Severity:** HIGH - Data corruption/modification of other users' data

**Recommended Fix:**

Update migration to add WITH CHECK:

```sql
DROP POLICY "Users can update own record" ON users;

CREATE POLICY "Users can update own record"
  ON users FOR UPDATE
  USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);  -- <-- Add this

CREATE POLICY "Users can insert own record"
  ON users FOR INSERT
  WITH CHECK (auth.uid() = id);
```

---

#### 6. **HIGH: Profile Ownership Not Validated in Mutations**

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts`

**Vulnerability:**
The mutation functions don't validate the profile belongs to the authenticated user:

```typescript
export function useUpdateProfile() {
  return useMutation({
    mutationFn: async ({
      profileId,
      userId,  // <-- Passed in but not verified
      name,
      headline,
      bio,
      expiresAt,
    }: UpdateProfileInput) => {
      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('id', profileId)  // <-- Only checks profile ID
        // Missing: .eq('user_id', userId)
        .select()
        .single()
    }
  })
}
```

**Problem:** The RLS policy will reject this, but an attacker could:
1. Fetch a profile ID from metadata
2. Try to update it with their token
3. While RLS prevents it, it's bad practice to rely solely on DB-level protection

**Severity:** HIGH - Missing application-level validation

**Recommended Fix:**

```typescript
export function useUpdateProfile() {
  const { authUser } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({
      profileId,
      userId,
      name,
      headline,
      bio,
      expiresAt,
    }: UpdateProfileInput) => {
      // Validate auth user matches the userId
      if (!authUser || authUser.id !== userId) {
        throw new Error('Unauthorized: Cannot update profiles for other users')
      }

      const updates: ProfileUpdate = {
        updated_at: new Date().toISOString(),
      }

      if (name !== undefined) updates.name = name
      if (headline !== undefined) updates.headline = headline
      if (bio !== undefined) updates.bio = bio
      if (expiresAt !== undefined) updates.expires_at = expiresAt

      const { data, error } = await supabase
        .from('profiles')
        .update(updates)
        .eq('id', profileId)
        .eq('user_id', userId)  // <-- Add this for defense in depth
        .select()
        .single()

      if (error) {
        throw new Error(`Failed to update profile: ${error.message}`)
      }

      return data
    },
    onSuccess: (_, variables) => {
      // ... invalidate cache
    },
  })
}
```

Apply the same fix to:
- `useToggleProfile` (line 143)
- `useRegenerateProfileToken` (line 175)
- `useDeleteProfile` (line 212)
- `useUpdateProfileStories` (line 249)

---

### MEDIUM SEVERITY ISSUES

#### 7. **MEDIUM: Profile Share Token Generation Uses Weak Entropy**

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts` (lines 6-15)

**Vulnerability:**
The token generation is reasonable but has minor issues:

```typescript
function generateToken(): string {
  const array = new Uint8Array(TOKEN_LENGTH)
  crypto.getRandomValues(array)
  return Array.from(array, (byte) => TOKEN_CHARS[byte % TOKEN_CHARS.length]).join('')
}
```

**Issues:**
1. `TOKEN_LENGTH = 8` characters from 54 alphabet = ~47 bits of entropy
2. Modulo bias: `byte % TOKEN_CHARS.length` creates slight bias (256 % 54 != 0)
3. Should be 12+ characters for URL tokens, especially for sensitive share links

**Attack:** Attacker could brute force tokens: 54^8 = ~7.2 trillion combinations, feasible with GPU acceleration over weeks.

**Severity:** MEDIUM - Brute force feasible but slow, and tokens are optional

**Recommended Fix:**

```typescript
// Use Base32 encoding (no modulo bias) and increase length
const TOKEN_CHARS = '23456789ABCDEFGHJKMNPQRSTUVWXYZ' // 32 chars = 5 bits each
const TOKEN_LENGTH = 16 // 80 bits entropy

function generateToken(): string {
  const array = new Uint8Array(TOKEN_LENGTH)
  crypto.getRandomValues(array)
  
  // Use Base32 to avoid modulo bias
  let result = ''
  let bits = 0
  let buffer = 0
  
  for (let i = 0; i < array.length; i++) {
    buffer = (buffer << 8) | array[i]
    bits += 8
    
    while (bits >= 5) {
      bits -= 5
      result += TOKEN_CHARS[(buffer >> bits) & 31]
    }
  }
  
  if (bits > 0) {
    result += TOKEN_CHARS[(buffer << (5 - bits)) & 31]
  }
  
  return result
}

// Or use this simpler approach
function generateToken(): string {
  // 16 bytes = 128 bits entropy
  const bytes = new Uint8Array(16)
  crypto.getRandomValues(bytes)
  return Array.from(bytes, x => x.toString(16).padStart(2, '0')).join('')
}
```

---

#### 8. **MEDIUM: No Rate Limiting on Public Profile Access**

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/usePublicProfile.ts` & migration 009

**Vulnerability:**
The `get_public_profile` and `get_public_profile_stories` functions can be called unlimited times:

```typescript
void (async () => {
  try {
    await supabase.rpc('increment_profile_view', { p_share_token: token })
  } catch (err) {
    logger.error('Failed to update view count', err)
  }
})()
```

**Attack:** An attacker could:
1. Get a valid share token (via social engineering or brute force)
2. Call the RPC repeatedly to spam increment
3. DoS the database with millions of calls
4. Inflate view counts artificially

**Severity:** MEDIUM - DoS/data integrity risk

**Recommended Fix:**

Add rate limiting in application:

```typescript
// In usePublicProfile.ts
const rateLimitKey = `profile_view_${token}`

export function usePublicProfile(token: string | undefined) {
  const [lastViewTime, setLastViewTime] = useState<number>(0)
  
  return useQuery({
    queryFn: async (): Promise<PublicProfile | null> => {
      if (!token) return null

      // Fetch profile (unchanged)
      const { data: profileData, error: profileError } = await supabase
        .rpc('get_public_profile', { p_share_token: token })
        .maybeSingle()

      if (profileError || !profileData) {
        return null
      }

      // Rate limit view increments - max 1 per 30 seconds per session
      const now = Date.now()
      if (now - lastViewTime > 30000) {
        void (async () => {
          try {
            await supabase.rpc('increment_profile_view', { p_share_token: token })
            setLastViewTime(now)
          } catch (err) {
            logger.error('Failed to update view count', err)
          }
        })()
      }

      // ... rest of function
    },
  })
}
```

Add database-level rate limiting:

```sql
-- Track rate limit in a separate table
CREATE TABLE profile_view_rate_limit (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  share_token TEXT NOT NULL,
  ip_address INET NOT NULL,
  view_count INT DEFAULT 1,
  last_view_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(share_token, ip_address)
);

-- Modified increment function
CREATE OR REPLACE FUNCTION increment_profile_view(p_share_token TEXT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  -- Check rate limit first (max 100 views per hour per IP)
  INSERT INTO profile_view_rate_limit (share_token, ip_address, view_count, last_view_at)
  VALUES (p_share_token, inet_client_addr(), 1, now())
  ON CONFLICT (share_token, ip_address) DO UPDATE
  SET 
    view_count = CASE 
      WHEN now() - last_view_at < interval '1 hour' AND view_count >= 100 THEN view_count
      ELSE view_count + 1
    END,
    last_view_at = CASE 
      WHEN now() - last_view_at < interval '1 hour' AND view_count >= 100 THEN last_view_at
      ELSE now()
    END;

  -- Only increment if not rate limited
  IF (SELECT view_count FROM profile_view_rate_limit 
      WHERE share_token = p_share_token 
      AND ip_address = inet_client_addr()) < 100 THEN
    UPDATE profiles
    SET
      view_count = view_count + 1,
      last_viewed_at = now()
    WHERE share_token = p_share_token
      AND is_active = true
      AND (expires_at IS NULL OR expires_at > now());
  END IF;
END;
$$;
```

---

#### 9. **MEDIUM: Cross-User Story Addition Not Prevented**

**File:** `/Users/ryan/projects/level2bio/src/features/profile/hooks/useProfileMutations.ts` (lines 239-292)

**Vulnerability:**
The `useUpdateProfileStories` function doesn't validate that the stories belong to the authenticated user:

```typescript
export function useUpdateProfileStories() {
  return useMutation({
    mutationFn: async ({ profileId, storyIds }: UpdateProfileStoriesInput) => {
      // No validation that storyIds belong to the current user!
      
      const profileStories = storyIds.map((storyId, index) => ({
        profile_id: profileId,
        work_story_id: storyId,  // <-- Could be any story ID
        display_order: index,
      }))

      const { error: insertError } = await supabase
        .from('profile_stories')
        .insert(profileStories)
    },
  })
}
```

**Attack Scenario:**
1. User A and User B both have stories
2. Attacker (User A) discovers User B's story_id
3. Attacker calls `useUpdateProfileStories({ profileId: 'user-a-profile', storyIds: ['user-b-story-id'] })`
4. RLS policy prevents insertion (because profile ownership is checked), but it's bad design

**Severity:** MEDIUM - Relies on RLS only, no app-level check

**Recommended Fix:**

```typescript
export function useUpdateProfileStories() {
  const { authUser } = useAuth()
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async ({ profileId, userId, storyIds }: UpdateProfileStoriesInput) => {
      // Verify auth user owns both the profile and stories
      if (!authUser || authUser.id !== userId) {
        throw new Error('Unauthorized')
      }

      // Validate that stories belong to this user
      if (storyIds.length > 0) {
        const { data: stories, error: checkError } = await supabase
          .from('work_stories')
          .select('id')
          .eq('user_id', userId)
          .in('id', storyIds)

        if (checkError || !stories || stories.length !== storyIds.length) {
          throw new Error('One or more stories do not belong to you')
        }
      }

      // Delete existing profile_stories
      const { error: deleteError } = await supabase
        .from('profile_stories')
        .delete()
        .eq('profile_id', profileId)

      if (deleteError) {
        throw new Error(`Failed to update profile stories: ${deleteError.message}`)
      }

      // Insert new profile_stories
      if (storyIds.length > 0) {
        const profileStories = storyIds.map((storyId, index) => ({
          profile_id: profileId,
          work_story_id: storyId,
          display_order: index,
        }))

        const { error: insertError } = await supabase
          .from('profile_stories')
          .insert(profileStories)

        if (insertError) {
          throw new Error(`Failed to update profile stories: ${insertError.message}`)
        }
      }

      // Update profile timestamp
      await supabase
        .from('profiles')
        .update({ updated_at: new Date().toISOString() })
        .eq('id', profileId)
    },
  })
}
```

---

#### 10. **MEDIUM: Storage Bucket Public Access Without Verification**

**File:** `/Users/ryan/projects/level2bio/supabase/migrations/008_storage_buckets.sql` (lines 8-25)

**Vulnerability:**
The storage bucket is marked `public = true`:

```sql
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'story-assets',
  'story-assets',
  true,  -- <-- Public bucket
  52428800,
  ARRAY['image/jpeg', 'image/png', ...]
)
```

**Problem:** While the RLS policies restrict uploads to users' own folders, the public bucket allows anyone to:
1. List all files (if directory listing is enabled)
2. Guess file paths
3. Access files without going through the application

**Current Mitigation:** The upload paths include user IDs (`${userId}/${storyId}/${timestamp}-${sanitizedName}`), making guessing harder, but not impossible.

**Severity:** MEDIUM - Could leak private files if paths are guessable

**Recommended Fix:**

```sql
-- Keep bucket private by default
UPDATE storage.buckets
SET public = false
WHERE id = 'story-assets';

-- Add more restrictive RLS policy
DROP POLICY IF EXISTS "Anyone can view story assets" ON storage.objects;

-- Only allow public access via authenticated requests with proper token validation
CREATE POLICY "Authenticated users can view story assets"
  ON storage.objects FOR SELECT
  TO authenticated
  USING (bucket_id = 'story-assets');

-- Create a function to generate signed URLs for public sharing
CREATE OR REPLACE FUNCTION get_asset_signed_url(p_file_path TEXT)
RETURNS TEXT
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT 'https://storage-url.../signed-url-token'::text
$$;
```

In application code:

```typescript
// Instead of using public URLs directly, use signed URLs
const { data, error } = supabase.storage
  .from('story-assets')
  .createSignedUrl(filePath, 86400) // 24-hour expiration

if (error) {
  throw new Error('Failed to generate asset URL')
}

const signedUrl = data.signedUrl
```

---

### LOW SEVERITY ISSUES

#### 11. **LOW: Missing FORCE ROW LEVEL SECURITY**

**Files:** All migrations

**Issue:** Tables don't explicitly disable the ability to disable RLS:

```sql
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
-- Should add:
ALTER TABLE profiles FORCE ROW LEVEL SECURITY;
```

**Fix:**
```sql
-- In each migration after enabling RLS
ALTER TABLE users FORCE ROW LEVEL SECURITY;
ALTER TABLE work_stories FORCE ROW LEVEL SECURITY;
ALTER TABLE share_links FORCE ROW LEVEL SECURITY;
ALTER TABLE profiles FORCE ROW LEVEL SECURITY;
ALTER TABLE profile_stories FORCE ROW LEVEL SECURITY;
```

---

#### 12. **LOW: No Audit Logging for Sensitive Operations**

**Issue:** No audit trail for profile token regeneration, profile deactivation, or story deletion.

**Fix:**
```sql
CREATE TABLE audit_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id),
  action TEXT NOT NULL,
  resource_type TEXT NOT NULL,
  resource_id UUID,
  details JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- Example: log token regeneration
CREATE TRIGGER profile_token_regen_audit
AFTER UPDATE OF share_token ON profiles
FOR EACH ROW
WHEN (OLD.share_token != NEW.share_token)
EXECUTE FUNCTION log_audit('profile_token_regenerated', 'profiles', NEW.id);
```

---

#### 13. **LOW: Missing Content-Security-Policy for Profile Embeds**

**Issue:** Profile content displays markdown with user-provided HTML. While react-markdown is used with sanitization, there's no CSP header to prevent XSS.

**Fix:** Add to server configuration:
```
Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' https:; frame-src 'none'
```

---

## SUMMARY TABLE

| # | Severity | Title | Location | Status |
|---|----------|-------|----------|--------|
| 1 | CRITICAL | User ID Takeover in Auth Sync | AuthContext.tsx | REQUIRES FIX |
| 2 | CRITICAL | Missing Profile Access Validation | useProfiles.ts | REQUIRES FIX |
| 3 | CRITICAL | Token Enumeration via Timing Attack | migration 007 | REQUIRES FIX |
| 4 | HIGH | RLS Policy Recursion Risk | migration 005 | REVIEW |
| 5 | HIGH | Missing WITH CHECK on User Update | migration 004 | REQUIRES FIX |
| 6 | HIGH | Profile Ownership Not Validated | useProfileMutations.ts | REQUIRES FIX |
| 7 | MEDIUM | Weak Token Entropy | useProfileMutations.ts | REQUIRES FIX |
| 8 | MEDIUM | No Rate Limiting on Views | usePublicProfile.ts | REQUIRES FIX |
| 9 | MEDIUM | Cross-User Story Addition | useProfileMutations.ts | REQUIRES FIX |
| 10 | MEDIUM | Public Storage Access | migration 008 | REQUIRES FIX |
| 11 | LOW | Missing FORCE ROW LEVEL SECURITY | All migrations | REQUIRES FIX |
| 12 | LOW | No Audit Logging | All | NICE TO HAVE |
| 13 | LOW | Missing CSP Headers | Server config | NICE TO HAVE |

---

## TESTING RECOMMENDATIONS

```typescript
// Test suite to verify fixes
describe('Security - RLS & Access Control', () => {
  it('should prevent user A from viewing user B profiles', async () => {
    const userA = await signUp('a@example.com')
    const userB = await signUp('b@example.com')
    
    await setSession(userA)
    const result = await supabase
      .from('profiles')
      .select('*')
      .eq('user_id', userB.id)
    
    expect(result.data).toEqual([]) // Should be empty
  })
  
  it('should prevent user A from modifying user B stories', async () => {
    const userA = await signUp('a@example.com')
    const userB = await signUp('b@example.com')
    const storyB = await createStory(userB)
    
    await setSession(userA)
    const result = await supabase
      .from('work_stories')
      .update({ title: 'Hacked' })
      .eq('id', storyB.id)
    
    expect(result.error).toBeDefined() // Should fail
  })
})
```

---

This audit reveals that while the codebase has good foundational RLS policies, several critical issues require immediate attention before production deployment. The three critical findings especially need urgent fixes as they could lead to account takeover or data breach.
